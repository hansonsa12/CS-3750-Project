{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers; // Default config for a category scale\n\n  var defaultConfig = {\n    position: 'bottom'\n  };\n  var DatasetScale = Chart.Scale.extend({\n    /**\n    * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n    * else fall back to data.labels\n    * @private\n    */\n    getLabels: function () {\n      var data = this.chart.data;\n      return (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n    },\n    // Implement this so that\n    determineDataLimits: function () {\n      var me = this;\n      var labels = me.getLabels();\n      me.minIndex = 0;\n      me.maxIndex = labels.length - 1;\n      var findIndex;\n\n      if (me.options.ticks.min !== undefined) {\n        // user specified min value\n        findIndex = helpers.indexOf(labels, me.options.ticks.min);\n        me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n      }\n\n      if (me.options.ticks.max !== undefined) {\n        // user specified max value\n        findIndex = helpers.indexOf(labels, me.options.ticks.max);\n        me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n      }\n\n      me.min = labels[me.minIndex];\n      me.max = labels[me.maxIndex];\n    },\n    buildTicks: function () {\n      var me = this;\n      var labels = me.getLabels(); // If we are viewing some subset of labels, slice the original array\n\n      me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      var me = this;\n      var data = me.chart.data;\n      var isHorizontal = me.isHorizontal();\n\n      if (data.yLabels && !isHorizontal) {\n        return me.getRightValue(data.datasets[datasetIndex].data[index]);\n      }\n\n      return me.ticks[index - me.minIndex];\n    },\n    // Used to get data value locations.  Value can either be an index or a numerical value\n    getPixelForValue: function (value, index, datasetIndex, includeOffset) {\n      var me = this; // 1 is added because we need the length but we have the indexes\n\n      var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);\n\n      if (value !== undefined && isNaN(index)) {\n        var labels = me.getLabels();\n        var idx = labels.indexOf(value);\n        index = idx !== -1 ? idx : index;\n      }\n\n      if (me.isHorizontal()) {\n        var valueWidth = me.width / offsetAmt;\n        var widthOffset = valueWidth * (index - me.minIndex);\n\n        if (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {\n          widthOffset += valueWidth / 2;\n        }\n\n        return me.left + Math.round(widthOffset);\n      }\n\n      var valueHeight = me.height / offsetAmt;\n      var heightOffset = valueHeight * (index - me.minIndex);\n\n      if (me.options.gridLines.offsetGridLines && includeOffset) {\n        heightOffset += valueHeight / 2;\n      }\n\n      return me.top + Math.round(heightOffset);\n    },\n    getPixelForTick: function (index, includeOffset) {\n      return this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var value;\n      var offsetAmt = Math.max(me.ticks.length - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);\n      var horz = me.isHorizontal();\n      var valueDimension = (horz ? me.width : me.height) / offsetAmt;\n      pixel -= horz ? me.left : me.top;\n\n      if (me.options.gridLines.offsetGridLines) {\n        pixel -= valueDimension / 2;\n      }\n\n      if (pixel <= 0) {\n        value = 0;\n      } else {\n        value = Math.round(pixel / valueDimension);\n      }\n\n      return value;\n    },\n    getBasePixel: function () {\n      return this.bottom;\n    }\n  });\n  Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/scales/scale.category.js"],"names":["module","exports","Chart","helpers","defaultConfig","position","DatasetScale","Scale","extend","getLabels","data","chart","isHorizontal","xLabels","yLabels","labels","determineDataLimits","me","minIndex","maxIndex","length","findIndex","options","ticks","min","undefined","indexOf","max","buildTicks","slice","getLabelForIndex","index","datasetIndex","getRightValue","datasets","getPixelForValue","value","includeOffset","offsetAmt","Math","gridLines","offsetGridLines","isNaN","idx","valueWidth","width","widthOffset","left","round","valueHeight","height","heightOffset","top","getPixelForTick","getValueForPixel","pixel","horz","valueDimension","getBasePixel","bottom","scaleService","registerScaleType"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\t// Default config for a category scale\n\tvar defaultConfig = {\n\t\tposition: 'bottom'\n\t};\n\n\tvar DatasetScale = Chart.Scale.extend({\n\t\t/**\n\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t\t* else fall back to data.labels\n\t\t* @private\n\t\t*/\n\t\tgetLabels: function() {\n\t\t\tvar data = this.chart.data;\n\t\t\treturn (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t},\n\t\t// Implement this so that\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\tme.minIndex = 0;\n\t\t\tme.maxIndex = labels.length - 1;\n\t\t\tvar findIndex;\n\n\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t// user specified min value\n\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.min);\n\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t}\n\n\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t// user specified max value\n\t\t\t\tfindIndex = helpers.indexOf(labels, me.options.ticks.max);\n\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t}\n\n\t\t\tme.min = labels[me.minIndex];\n\t\t\tme.max = labels[me.maxIndex];\n\t\t},\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t},\n\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (data.yLabels && !isHorizontal) {\n\t\t\t\treturn me.getRightValue(data.datasets[datasetIndex].data[index]);\n\t\t\t}\n\t\t\treturn me.ticks[index - me.minIndex];\n\t\t},\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: function(value, index, datasetIndex, includeOffset) {\n\t\t\tvar me = this;\n\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\n\t\t\tif (value !== undefined && isNaN(index)) {\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t}\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex));\n\n\t\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {\n\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t}\n\n\t\t\t\treturn me.left + Math.round(widthOffset);\n\t\t\t}\n\t\t\tvar valueHeight = me.height / offsetAmt;\n\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex));\n\n\t\t\tif (me.options.gridLines.offsetGridLines && includeOffset) {\n\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t}\n\n\t\t\treturn me.top + Math.round(heightOffset);\n\t\t},\n\t\tgetPixelForTick: function(index, includeOffset) {\n\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar value;\n\t\t\tvar offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\t\tvar horz = me.isHorizontal();\n\t\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\n\t\t\tpixel -= horz ? me.left : me.top;\n\n\t\t\tif (me.options.gridLines.offsetGridLines) {\n\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t}\n\n\t\t\tif (pixel <= 0) {\n\t\t\t\tvalue = 0;\n\t\t\t} else {\n\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t},\n\t\tgetBasePixel: function() {\n\t\t\treturn this.bottom;\n\t\t}\n\t});\n\n\tChart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n\n};\n"]},"metadata":{},"sourceType":"script"}