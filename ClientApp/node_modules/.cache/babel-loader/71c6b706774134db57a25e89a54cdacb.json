{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  var globalDefaults = Chart.defaults.global;\n  Chart.defaults.global.elements.line = {\n    tension: 0.4,\n    backgroundColor: globalDefaults.defaultColor,\n    borderWidth: 3,\n    borderColor: globalDefaults.defaultColor,\n    borderCapStyle: 'butt',\n    borderDash: [],\n    borderDashOffset: 0.0,\n    borderJoinStyle: 'miter',\n    capBezierPoints: true,\n    fill: true // do we fill in the area between the line and its base axis\n\n  };\n  Chart.elements.Line = Chart.Element.extend({\n    draw: function () {\n      var me = this;\n      var vm = me._view;\n      var spanGaps = vm.spanGaps;\n      var fillPoint = vm.scaleZero;\n      var loop = me._loop; // Handle different fill modes for cartesian lines\n\n      if (!loop) {\n        if (vm.fill === 'top') {\n          fillPoint = vm.scaleTop;\n        } else if (vm.fill === 'bottom') {\n          fillPoint = vm.scaleBottom;\n        }\n      }\n\n      var ctx = me._chart.ctx;\n      ctx.save(); // Helper function to draw a line to a point\n\n      function lineToPoint(previousPoint, point) {\n        var pointVM = point._view;\n\n        if (point._view.steppedLine === true) {\n          ctx.lineTo(pointVM.x, previousPoint._view.y);\n          ctx.lineTo(pointVM.x, pointVM.y);\n        } else if (point._view.tension === 0) {\n          ctx.lineTo(pointVM.x, pointVM.y);\n        } else {\n          ctx.bezierCurveTo(previousPoint._view.controlPointNextX, previousPoint._view.controlPointNextY, pointVM.controlPointPreviousX, pointVM.controlPointPreviousY, pointVM.x, pointVM.y);\n        }\n      }\n\n      var points = me._children.slice(); // clone array\n\n\n      var lastDrawnIndex = -1; // If we are looping, adding the first point again\n\n      if (loop && points.length) {\n        points.push(points[0]);\n      }\n\n      var index, current, previous, currentVM; // Fill Line\n\n      if (points.length && vm.fill) {\n        ctx.beginPath();\n\n        for (index = 0; index < points.length; ++index) {\n          current = points[index];\n          previous = helpers.previousItem(points, index);\n          currentVM = current._view; // First point moves to it's starting position no matter what\n\n          if (index === 0) {\n            if (loop) {\n              ctx.moveTo(fillPoint.x, fillPoint.y);\n            } else {\n              ctx.moveTo(currentVM.x, fillPoint);\n            }\n\n            if (!currentVM.skip) {\n              lastDrawnIndex = index;\n              ctx.lineTo(currentVM.x, currentVM.y);\n            }\n          } else {\n            previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n            if (currentVM.skip) {\n              // Only do this if this is the first point that is skipped\n              if (!spanGaps && lastDrawnIndex === index - 1) {\n                if (loop) {\n                  ctx.lineTo(fillPoint.x, fillPoint.y);\n                } else {\n                  ctx.lineTo(previous._view.x, fillPoint);\n                }\n              }\n            } else {\n              if (lastDrawnIndex !== index - 1) {\n                // There was a gap and this is the first point after the gap. If we've never drawn a point, this is a special case.\n                // If the first data point is NaN, then there is no real gap to skip\n                if (spanGaps && lastDrawnIndex !== -1) {\n                  // We are spanning the gap, so simple draw a line to this point\n                  lineToPoint(previous, current);\n                } else if (loop) {\n                  ctx.lineTo(currentVM.x, currentVM.y);\n                } else {\n                  ctx.lineTo(currentVM.x, fillPoint);\n                  ctx.lineTo(currentVM.x, currentVM.y);\n                }\n              } else {\n                // Line to next point\n                lineToPoint(previous, current);\n              }\n\n              lastDrawnIndex = index;\n            }\n          }\n        }\n\n        if (!loop && lastDrawnIndex !== -1) {\n          ctx.lineTo(points[lastDrawnIndex]._view.x, fillPoint);\n        }\n\n        ctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;\n        ctx.closePath();\n        ctx.fill();\n      } // Stroke Line Options\n\n\n      var globalOptionLineElements = globalDefaults.elements.line;\n      ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash\n\n      if (ctx.setLineDash) {\n        ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n      }\n\n      ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n      ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n      ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n      ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line\n\n      ctx.beginPath();\n      lastDrawnIndex = -1;\n\n      for (index = 0; index < points.length; ++index) {\n        current = points[index];\n        previous = helpers.previousItem(points, index);\n        currentVM = current._view; // First point moves to it's starting position no matter what\n\n        if (index === 0) {\n          if (!currentVM.skip) {\n            ctx.moveTo(currentVM.x, currentVM.y);\n            lastDrawnIndex = index;\n          }\n        } else {\n          previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n          if (!currentVM.skip) {\n            if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {\n              // There was a gap and this is the first point after the gap\n              ctx.moveTo(currentVM.x, currentVM.y);\n            } else {\n              // Line to next point\n              lineToPoint(previous, current);\n            }\n\n            lastDrawnIndex = index;\n          }\n        }\n      }\n\n      ctx.stroke();\n      ctx.restore();\n    }\n  });\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/elements/element.line.js"],"names":["module","exports","Chart","helpers","globalDefaults","defaults","global","elements","line","tension","backgroundColor","defaultColor","borderWidth","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","capBezierPoints","fill","Line","Element","extend","draw","me","vm","_view","spanGaps","fillPoint","scaleZero","loop","_loop","scaleTop","scaleBottom","ctx","_chart","save","lineToPoint","previousPoint","point","pointVM","steppedLine","lineTo","x","y","bezierCurveTo","controlPointNextX","controlPointNextY","controlPointPreviousX","controlPointPreviousY","points","_children","slice","lastDrawnIndex","length","push","index","current","previous","currentVM","beginPath","previousItem","moveTo","skip","fillStyle","closePath","globalOptionLineElements","lineCap","setLineDash","lineDashOffset","lineJoin","lineWidth","strokeStyle","stroke","restore"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar globalDefaults = Chart.defaults.global;\n\n\tChart.defaults.global.elements.line = {\n\t\ttension: 0.4,\n\t\tbackgroundColor: globalDefaults.defaultColor,\n\t\tborderWidth: 3,\n\t\tborderColor: globalDefaults.defaultColor,\n\t\tborderCapStyle: 'butt',\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0,\n\t\tborderJoinStyle: 'miter',\n\t\tcapBezierPoints: true,\n\t\tfill: true, // do we fill in the area between the line and its base axis\n\t};\n\n\tChart.elements.Line = Chart.Element.extend({\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar vm = me._view;\n\t\t\tvar spanGaps = vm.spanGaps;\n\t\t\tvar fillPoint = vm.scaleZero;\n\t\t\tvar loop = me._loop;\n\n\t\t\t// Handle different fill modes for cartesian lines\n\t\t\tif (!loop) {\n\t\t\t\tif (vm.fill === 'top') {\n\t\t\t\t\tfillPoint = vm.scaleTop;\n\t\t\t\t} else if (vm.fill === 'bottom') {\n\t\t\t\t\tfillPoint = vm.scaleBottom;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar ctx = me._chart.ctx;\n\t\t\tctx.save();\n\n\t\t\t// Helper function to draw a line to a point\n\t\t\tfunction lineToPoint(previousPoint, point) {\n\t\t\t\tvar pointVM = point._view;\n\t\t\t\tif (point._view.steppedLine === true) {\n\t\t\t\t\tctx.lineTo(pointVM.x, previousPoint._view.y);\n\t\t\t\t\tctx.lineTo(pointVM.x, pointVM.y);\n\t\t\t\t} else if (point._view.tension === 0) {\n\t\t\t\t\tctx.lineTo(pointVM.x, pointVM.y);\n\t\t\t\t} else {\n\t\t\t\t\tctx.bezierCurveTo(\n\t\t\t\t\t\tpreviousPoint._view.controlPointNextX,\n\t\t\t\t\t\tpreviousPoint._view.controlPointNextY,\n\t\t\t\t\t\tpointVM.controlPointPreviousX,\n\t\t\t\t\t\tpointVM.controlPointPreviousY,\n\t\t\t\t\t\tpointVM.x,\n\t\t\t\t\t\tpointVM.y\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar points = me._children.slice(); // clone array\n\t\t\tvar lastDrawnIndex = -1;\n\n\t\t\t// If we are looping, adding the first point again\n\t\t\tif (loop && points.length) {\n\t\t\t\tpoints.push(points[0]);\n\t\t\t}\n\n\t\t\tvar index, current, previous, currentVM;\n\n\t\t\t// Fill Line\n\t\t\tif (points.length && vm.fill) {\n\t\t\t\tctx.beginPath();\n\n\t\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\t\tcurrent = points[index];\n\t\t\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\t\t\tcurrentVM = current._view;\n\n\t\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\tctx.moveTo(fillPoint.x, fillPoint.y);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.moveTo(currentVM.x, fillPoint);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\t\t\tif (currentVM.skip) {\n\t\t\t\t\t\t\t// Only do this if this is the first point that is skipped\n\t\t\t\t\t\t\tif (!spanGaps && lastDrawnIndex === (index - 1)) {\n\t\t\t\t\t\t\t\tif (loop) {\n\t\t\t\t\t\t\t\t\tctx.lineTo(fillPoint.x, fillPoint.y);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tctx.lineTo(previous._view.x, fillPoint);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (lastDrawnIndex !== (index - 1)) {\n\t\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap. If we've never drawn a point, this is a special case.\n\t\t\t\t\t\t\t\t// If the first data point is NaN, then there is no real gap to skip\n\t\t\t\t\t\t\t\tif (spanGaps && lastDrawnIndex !== -1) {\n\t\t\t\t\t\t\t\t\t// We are spanning the gap, so simple draw a line to this point\n\t\t\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t\t\t} else if (loop) {\n\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, fillPoint);\n\t\t\t\t\t\t\t\t\tctx.lineTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!loop && lastDrawnIndex !== -1) {\n\t\t\t\t\tctx.lineTo(points[lastDrawnIndex]._view.x, fillPoint);\n\t\t\t\t}\n\n\t\t\t\tctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.fill();\n\t\t\t}\n\n\t\t\t// Stroke Line Options\n\t\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\n\t\t\t// IE 9 and 10 do not support line dash\n\t\t\tif (ctx.setLineDash) {\n\t\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t\t}\n\n\t\t\tctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n\t\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\t\tctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n\t\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\n\t\t\t// Stroke Line\n\t\t\tctx.beginPath();\n\t\t\tlastDrawnIndex = -1;\n\n\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\tcurrent = points[index];\n\t\t\t\tprevious = helpers.previousItem(points, index);\n\t\t\t\tcurrentVM = current._view;\n\n\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\tlineToPoint(previous, current);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.stroke();\n\t\t\tctx.restore();\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}