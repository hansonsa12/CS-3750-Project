{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers,\n      noop = helpers.noop;\n  Chart.LinearScaleBase = Chart.Scale.extend({\n    handleTickRangeOptions: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n      // do nothing since that would make the chart weird. If the user really wants a weird chart\n      // axis, they can manually override it\n\n      if (tickOpts.beginAtZero) {\n        var minSign = helpers.sign(me.min);\n        var maxSign = helpers.sign(me.max);\n\n        if (minSign < 0 && maxSign < 0) {\n          // move the top up to 0\n          me.max = 0;\n        } else if (minSign > 0 && maxSign > 0) {\n          // move the bottom down to 0\n          me.min = 0;\n        }\n      }\n\n      if (tickOpts.min !== undefined) {\n        me.min = tickOpts.min;\n      } else if (tickOpts.suggestedMin !== undefined) {\n        me.min = Math.min(me.min, tickOpts.suggestedMin);\n      }\n\n      if (tickOpts.max !== undefined) {\n        me.max = tickOpts.max;\n      } else if (tickOpts.suggestedMax !== undefined) {\n        me.max = Math.max(me.max, tickOpts.suggestedMax);\n      }\n\n      if (me.min === me.max) {\n        me.max++;\n\n        if (!tickOpts.beginAtZero) {\n          me.min--;\n        }\n      }\n    },\n    getTickLimit: noop,\n    handleDirectionalChanges: noop,\n    buildTicks: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of\n      // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n      // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n      // the graph. Make sure we always have at least 2 ticks\n\n      var maxTicks = me.getTickLimit();\n      maxTicks = Math.max(2, maxTicks);\n      var numericGeneratorOptions = {\n        maxTicks: maxTicks,\n        min: tickOpts.min,\n        max: tickOpts.max,\n        stepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n      };\n      var ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);\n      me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n      me.max = helpers.max(ticks);\n      me.min = helpers.min(ticks);\n\n      if (tickOpts.reverse) {\n        ticks.reverse();\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n    },\n    convertTicksToLabels: function () {\n      var me = this;\n      me.ticksAsNumbers = me.ticks.slice();\n      me.zeroLineIndex = me.ticks.indexOf(0);\n      Chart.Scale.prototype.convertTicksToLabels.call(me);\n    }\n  });\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/scales/scale.linearbase.js"],"names":["module","exports","Chart","helpers","noop","LinearScaleBase","Scale","extend","handleTickRangeOptions","me","opts","options","tickOpts","ticks","beginAtZero","minSign","sign","min","maxSign","max","undefined","suggestedMin","Math","suggestedMax","getTickLimit","handleDirectionalChanges","buildTicks","maxTicks","numericGeneratorOptions","stepSize","getValueOrDefault","fixedStepSize","Ticks","generators","linear","reverse","start","end","convertTicksToLabels","ticksAsNumbers","slice","zeroLineIndex","indexOf","prototype","call"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers,\n\t\tnoop = helpers.noop;\n\n\tChart.LinearScaleBase = Chart.Scale.extend({\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t// axis, they can manually override it\n\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\tvar maxSign = helpers.sign(me.max);\n\n\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t// move the top up to 0\n\t\t\t\t\tme.max = 0;\n\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\tme.min = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\tme.min = tickOpts.min;\n\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t}\n\n\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\tme.max = tickOpts.max;\n\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t}\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tme.max++;\n\n\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\tme.min--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTickLimit: noop,\n\t\thandleDirectionalChanges: noop,\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\t\tvar numericGeneratorOptions = {\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max,\n\t\t\t\tstepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);\n\n\t\t\tme.handleDirectionalChanges();\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}