{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  var noop = helpers.noop;\n  Chart.defaults.global.legend = {\n    display: true,\n    position: 'top',\n    fullWidth: true,\n    // marks that this box should take the full width of the canvas (pushing down other boxes)\n    reverse: false,\n    // a callback that will handle\n    onClick: function (e, legendItem) {\n      var index = legendItem.datasetIndex;\n      var ci = this.chart;\n      var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment\n\n      meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart\n\n      ci.update();\n    },\n    onHover: null,\n    labels: {\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels: function (chart) {\n        var data = chart.data;\n        return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {\n          return {\n            text: dataset.label,\n            fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],\n            hidden: !chart.isDatasetVisible(i),\n            lineCap: dataset.borderCapStyle,\n            lineDash: dataset.borderDash,\n            lineDashOffset: dataset.borderDashOffset,\n            lineJoin: dataset.borderJoinStyle,\n            lineWidth: dataset.borderWidth,\n            strokeStyle: dataset.borderColor,\n            pointStyle: dataset.pointStyle,\n            // Below is extra data used for toggling the datasets\n            datasetIndex: i\n          };\n        }, this) : [];\n      }\n    }\n  };\n  /**\n   * Helper function to get the box width based on the usePointStyle option\n   * @param labelopts {Object} the label options on the legend\n   * @param fontSize {Number} the label font size\n   * @return {Number} width of the color box area\n   */\n\n  function getBoxWidth(labelOpts, fontSize) {\n    return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth;\n  }\n\n  Chart.Legend = Chart.Element.extend({\n    initialize: function (config) {\n      helpers.extend(this, config); // Contains hit boxes for each dataset (in dataset order)\n\n      this.legendHitBoxes = []; // Are we in doughnut mode which has a different data type\n\n      this.doughnutMode = false;\n    },\n    // These methods are ordered by lifecycle. Utilities then follow.\n    // Any function defined here is inherited by all legend types.\n    // Any function can be extended by the legend type\n    beforeUpdate: noop,\n    update: function (maxWidth, maxHeight, margins) {\n      var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n      me.beforeUpdate(); // Absorb the master measurements\n\n      me.maxWidth = maxWidth;\n      me.maxHeight = maxHeight;\n      me.margins = margins; // Dimensions\n\n      me.beforeSetDimensions();\n      me.setDimensions();\n      me.afterSetDimensions(); // Labels\n\n      me.beforeBuildLabels();\n      me.buildLabels();\n      me.afterBuildLabels(); // Fit\n\n      me.beforeFit();\n      me.fit();\n      me.afterFit(); //\n\n      me.afterUpdate();\n      return me.minSize;\n    },\n    afterUpdate: noop,\n    //\n    beforeSetDimensions: noop,\n    setDimensions: function () {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      if (me.isHorizontal()) {\n        // Reset position before calculating rotation\n        me.width = me.maxWidth;\n        me.left = 0;\n        me.right = me.width;\n      } else {\n        me.height = me.maxHeight; // Reset position before calculating rotation\n\n        me.top = 0;\n        me.bottom = me.height;\n      } // Reset padding\n\n\n      me.paddingLeft = 0;\n      me.paddingTop = 0;\n      me.paddingRight = 0;\n      me.paddingBottom = 0; // Reset minSize\n\n      me.minSize = {\n        width: 0,\n        height: 0\n      };\n    },\n    afterSetDimensions: noop,\n    //\n    beforeBuildLabels: noop,\n    buildLabels: function () {\n      var me = this;\n      var labelOpts = me.options.labels;\n      var legendItems = labelOpts.generateLabels.call(me, me.chart);\n\n      if (labelOpts.filter) {\n        legendItems = legendItems.filter(function (item) {\n          return labelOpts.filter(item, me.chart.data);\n        });\n      }\n\n      if (me.options.reverse) {\n        legendItems.reverse();\n      }\n\n      me.legendItems = legendItems;\n    },\n    afterBuildLabels: noop,\n    //\n    beforeFit: noop,\n    fit: function () {\n      var me = this;\n      var opts = me.options;\n      var labelOpts = opts.labels;\n      var display = opts.display;\n      var ctx = me.ctx;\n      var globalDefault = Chart.defaults.global,\n          itemOrDefault = helpers.getValueOrDefault,\n          fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n          fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n          fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n          labelFont = helpers.fontString(fontSize, fontStyle, fontFamily); // Reset hit boxes\n\n      var hitboxes = me.legendHitBoxes = [];\n      var minSize = me.minSize;\n      var isHorizontal = me.isHorizontal();\n\n      if (isHorizontal) {\n        minSize.width = me.maxWidth; // fill all the width\n\n        minSize.height = display ? 10 : 0;\n      } else {\n        minSize.width = display ? 10 : 0;\n        minSize.height = me.maxHeight; // fill all the height\n      } // Increase sizes here\n\n\n      if (display) {\n        ctx.font = labelFont;\n\n        if (isHorizontal) {\n          // Labels\n          // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n          var lineWidths = me.lineWidths = [0];\n          var totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;\n          ctx.textAlign = 'left';\n          ctx.textBaseline = 'top';\n          helpers.each(me.legendItems, function (legendItem, i) {\n            var boxWidth = getBoxWidth(labelOpts, fontSize);\n            var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n\n            if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n              totalHeight += fontSize + labelOpts.padding;\n              lineWidths[lineWidths.length] = me.left;\n            } // Store the hitbox width and height here. Final position will be updated in `draw`\n\n\n            hitboxes[i] = {\n              left: 0,\n              top: 0,\n              width: width,\n              height: fontSize\n            };\n            lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n          });\n          minSize.height += totalHeight;\n        } else {\n          var vPadding = labelOpts.padding;\n          var columnWidths = me.columnWidths = [];\n          var totalWidth = labelOpts.padding;\n          var currentColWidth = 0;\n          var currentColHeight = 0;\n          var itemHeight = fontSize + vPadding;\n          helpers.each(me.legendItems, function (legendItem, i) {\n            var boxWidth = getBoxWidth(labelOpts, fontSize);\n            var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column\n\n            if (currentColHeight + itemHeight > minSize.height) {\n              totalWidth += currentColWidth + labelOpts.padding;\n              columnWidths.push(currentColWidth); // previous column width\n\n              currentColWidth = 0;\n              currentColHeight = 0;\n            } // Get max width\n\n\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`\n\n            hitboxes[i] = {\n              left: 0,\n              top: 0,\n              width: itemWidth,\n              height: fontSize\n            };\n          });\n          totalWidth += currentColWidth;\n          columnWidths.push(currentColWidth);\n          minSize.width += totalWidth;\n        }\n      }\n\n      me.width = minSize.width;\n      me.height = minSize.height;\n    },\n    afterFit: noop,\n    // Shared Methods\n    isHorizontal: function () {\n      return this.options.position === 'top' || this.options.position === 'bottom';\n    },\n    // Actually draw the legend on the canvas\n    draw: function () {\n      var me = this;\n      var opts = me.options;\n      var labelOpts = opts.labels;\n      var globalDefault = Chart.defaults.global,\n          lineDefault = globalDefault.elements.line,\n          legendWidth = me.width,\n          lineWidths = me.lineWidths;\n\n      if (opts.display) {\n        var ctx = me.ctx,\n            cursor,\n            itemOrDefault = helpers.getValueOrDefault,\n            fontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),\n            fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n            fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n            fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n            labelFont = helpers.fontString(fontSize, fontStyle, fontFamily); // Canvas setup\n\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'top';\n        ctx.lineWidth = 0.5;\n        ctx.strokeStyle = fontColor; // for strikethrough effect\n\n        ctx.fillStyle = fontColor; // render in correct colour\n\n        ctx.font = labelFont;\n        var boxWidth = getBoxWidth(labelOpts, fontSize),\n            hitboxes = me.legendHitBoxes; // current position\n\n        var drawLegendBox = function (x, y, legendItem) {\n          if (isNaN(boxWidth) || boxWidth <= 0) {\n            return;\n          } // Set the ctx for the box\n\n\n          ctx.save();\n          ctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n          ctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n          ctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n          ctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n          ctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n          ctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n          var isLineWidthZero = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;\n\n          if (ctx.setLineDash) {\n            // IE 9 and 10 do not support line dash\n            ctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));\n          }\n\n          if (opts.labels && opts.labels.usePointStyle) {\n            // Recalculate x and y for drawPoint() because its expecting\n            // x and y to be center of figure (instead of top left)\n            var radius = fontSize * Math.SQRT2 / 2;\n            var offSet = radius / Math.SQRT2;\n            var centerX = x + offSet;\n            var centerY = y + offSet; // Draw pointStyle as legend symbol\n\n            Chart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n          } else {\n            // Draw box as legend symbol\n            if (!isLineWidthZero) {\n              ctx.strokeRect(x, y, boxWidth, fontSize);\n            }\n\n            ctx.fillRect(x, y, boxWidth, fontSize);\n          }\n\n          ctx.restore();\n        };\n\n        var fillText = function (x, y, legendItem, textWidth) {\n          ctx.fillText(legendItem.text, boxWidth + fontSize / 2 + x, y);\n\n          if (legendItem.hidden) {\n            // Strikethrough the text if hidden\n            ctx.beginPath();\n            ctx.lineWidth = 2;\n            ctx.moveTo(boxWidth + fontSize / 2 + x, y + fontSize / 2);\n            ctx.lineTo(boxWidth + fontSize / 2 + x + textWidth, y + fontSize / 2);\n            ctx.stroke();\n          }\n        }; // Horizontal\n\n\n        var isHorizontal = me.isHorizontal();\n\n        if (isHorizontal) {\n          cursor = {\n            x: me.left + (legendWidth - lineWidths[0]) / 2,\n            y: me.top + labelOpts.padding,\n            line: 0\n          };\n        } else {\n          cursor = {\n            x: me.left + labelOpts.padding,\n            y: me.top + labelOpts.padding,\n            line: 0\n          };\n        }\n\n        var itemHeight = fontSize + labelOpts.padding;\n        helpers.each(me.legendItems, function (legendItem, i) {\n          var textWidth = ctx.measureText(legendItem.text).width,\n              width = boxWidth + fontSize / 2 + textWidth,\n              x = cursor.x,\n              y = cursor.y;\n\n          if (isHorizontal) {\n            if (x + width >= legendWidth) {\n              y = cursor.y += itemHeight;\n              cursor.line++;\n              x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2;\n            }\n          } else if (y + itemHeight > me.bottom) {\n            x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n            y = cursor.y = me.top + labelOpts.padding;\n            cursor.line++;\n          }\n\n          drawLegendBox(x, y, legendItem);\n          hitboxes[i].left = x;\n          hitboxes[i].top = y; // Fill the actual label\n\n          fillText(x, y, legendItem, textWidth);\n\n          if (isHorizontal) {\n            cursor.x += width + labelOpts.padding;\n          } else {\n            cursor.y += itemHeight;\n          }\n        });\n      }\n    },\n\n    /**\n     * Handle an event\n     * @private\n     * @param {IEvent} event - The event to handle\n     * @return {Boolean} true if a change occured\n     */\n    handleEvent: function (e) {\n      var me = this;\n      var opts = me.options;\n      var type = e.type === 'mouseup' ? 'click' : e.type;\n      var changed = false;\n\n      if (type === 'mousemove') {\n        if (!opts.onHover) {\n          return;\n        }\n      } else if (type === 'click') {\n        if (!opts.onClick) {\n          return;\n        }\n      } else {\n        return;\n      } // Chart event already has relative position in it\n\n\n      var x = e.x,\n          y = e.y;\n\n      if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n        // See if we are touching one of the dataset boxes\n        var lh = me.legendHitBoxes;\n\n        for (var i = 0; i < lh.length; ++i) {\n          var hitBox = lh[i];\n\n          if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n            // Touching an element\n            if (type === 'click') {\n              // use e.native for backwards compatibility\n              opts.onClick.call(me, e.native, me.legendItems[i]);\n              changed = true;\n              break;\n            } else if (type === 'mousemove') {\n              // use e.native for backwards compatibility\n              opts.onHover.call(me, e.native, me.legendItems[i]);\n              changed = true;\n              break;\n            }\n          }\n        }\n      }\n\n      return changed;\n    }\n  });\n\n  function createNewLegendAndAttach(chartInstance, legendOpts) {\n    var legend = new Chart.Legend({\n      ctx: chartInstance.chart.ctx,\n      options: legendOpts,\n      chart: chartInstance\n    });\n    chartInstance.legend = legend;\n    Chart.layoutService.addBox(chartInstance, legend);\n  } // Register the legend plugin\n\n\n  Chart.plugins.register({\n    beforeInit: function (chartInstance) {\n      var legendOpts = chartInstance.options.legend;\n\n      if (legendOpts) {\n        createNewLegendAndAttach(chartInstance, legendOpts);\n      }\n    },\n    beforeUpdate: function (chartInstance) {\n      var legendOpts = chartInstance.options.legend;\n\n      if (legendOpts) {\n        legendOpts = helpers.configMerge(Chart.defaults.global.legend, legendOpts);\n\n        if (chartInstance.legend) {\n          chartInstance.legend.options = legendOpts;\n        } else {\n          createNewLegendAndAttach(chartInstance, legendOpts);\n        }\n      } else {\n        Chart.layoutService.removeBox(chartInstance, chartInstance.legend);\n        delete chartInstance.legend;\n      }\n    },\n    afterEvent: function (chartInstance, e) {\n      var legend = chartInstance.legend;\n\n      if (legend) {\n        legend.handleEvent(e);\n      }\n    }\n  });\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/core/core.legend.js"],"names":["module","exports","Chart","helpers","noop","defaults","global","legend","display","position","fullWidth","reverse","onClick","e","legendItem","index","datasetIndex","ci","chart","meta","getDatasetMeta","hidden","data","datasets","update","onHover","labels","boxWidth","padding","generateLabels","isArray","map","dataset","i","text","label","fillStyle","backgroundColor","isDatasetVisible","lineCap","borderCapStyle","lineDash","borderDash","lineDashOffset","borderDashOffset","lineJoin","borderJoinStyle","lineWidth","borderWidth","strokeStyle","borderColor","pointStyle","getBoxWidth","labelOpts","fontSize","usePointStyle","Math","SQRT2","Legend","Element","extend","initialize","config","legendHitBoxes","doughnutMode","beforeUpdate","maxWidth","maxHeight","margins","me","beforeSetDimensions","setDimensions","afterSetDimensions","beforeBuildLabels","buildLabels","afterBuildLabels","beforeFit","fit","afterFit","afterUpdate","minSize","isHorizontal","width","left","right","height","top","bottom","paddingLeft","paddingTop","paddingRight","paddingBottom","options","legendItems","call","filter","item","opts","ctx","globalDefault","itemOrDefault","getValueOrDefault","defaultFontSize","fontStyle","defaultFontStyle","fontFamily","defaultFontFamily","labelFont","fontString","hitboxes","font","lineWidths","totalHeight","length","textAlign","textBaseline","each","measureText","vPadding","columnWidths","totalWidth","currentColWidth","currentColHeight","itemHeight","itemWidth","push","max","draw","lineDefault","elements","line","legendWidth","cursor","fontColor","defaultFontColor","drawLegendBox","x","y","isNaN","save","defaultColor","isLineWidthZero","setLineDash","radius","offSet","centerX","centerY","canvasHelpers","drawPoint","strokeRect","fillRect","restore","fillText","textWidth","beginPath","moveTo","lineTo","stroke","handleEvent","type","changed","lh","hitBox","native","createNewLegendAndAttach","chartInstance","legendOpts","layoutService","addBox","plugins","register","beforeInit","configMerge","removeBox","afterEvent"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar noop = helpers.noop;\n\n\tChart.defaults.global.legend = {\n\n\t\tdisplay: true,\n\t\tposition: 'top',\n\t\tfullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\n\t\treverse: false,\n\n\t\t// a callback that will handle\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.datasetIndex;\n\t\t\tvar ci = this.chart;\n\t\t\tvar meta = ci.getDatasetMeta(index);\n\n\t\t\t// See controller.isDatasetVisible comment\n\t\t\tmeta.hidden = meta.hidden === null? !ci.data.datasets[index].hidden : null;\n\n\t\t\t// We hid a dataset ... rerender the chart\n\t\t\tci.update();\n\t\t},\n\n\t\tonHover: null,\n\n\t\tlabels: {\n\t\t\tboxWidth: 40,\n\t\t\tpadding: 10,\n\t\t\t// Generates labels shown in the legend\n\t\t\t// Valid properties to return:\n\t\t\t// text : text to display\n\t\t\t// fillStyle : fill of coloured box\n\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t// lineCap : cap style for line\n\t\t\t// lineDash\n\t\t\t// lineDashOffset :\n\t\t\t// lineJoin :\n\t\t\t// lineWidth :\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\n\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t};\n\t\t\t\t}, this) : [];\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Helper function to get the box width based on the usePointStyle option\n\t * @param labelopts {Object} the label options on the legend\n\t * @param fontSize {Number} the label font size\n\t * @return {Number} width of the color box area\n\t */\n\tfunction getBoxWidth(labelOpts, fontSize) {\n\t\treturn labelOpts.usePointStyle ?\n\t\t\tfontSize * Math.SQRT2 :\n\t\t\tlabelOpts.boxWidth;\n\t}\n\n\tChart.Legend = Chart.Element.extend({\n\n\t\tinitialize: function(config) {\n\t\t\thelpers.extend(this, config);\n\n\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\tthis.legendHitBoxes = [];\n\n\t\t\t// Are we in doughnut mode which has a different data type\n\t\t\tthis.doughnutMode = false;\n\t\t},\n\n\t\t// These methods are ordered by lifecycle. Utilities then follow.\n\t\t// Any function defined here is inherited by all legend types.\n\t\t// Any function can be extended by the legend type\n\n\t\tbeforeUpdate: noop,\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = margins;\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\t\t\t// Labels\n\t\t\tme.beforeBuildLabels();\n\t\t\tme.buildLabels();\n\t\t\tme.afterBuildLabels();\n\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\t\t},\n\t\tafterUpdate: noop,\n\n\t\t//\n\n\t\tbeforeSetDimensions: noop,\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\n\t\t\t// Reset minSize\n\t\t\tme.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t},\n\t\tafterSetDimensions: noop,\n\n\t\t//\n\n\t\tbeforeBuildLabels: noop,\n\t\tbuildLabels: function() {\n\t\t\tvar me = this;\n\t\t\tvar labelOpts = me.options.labels;\n\t\t\tvar legendItems = labelOpts.generateLabels.call(me, me.chart);\n\n\t\t\tif (labelOpts.filter) {\n\t\t\t\tlegendItems = legendItems.filter(function(item) {\n\t\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (me.options.reverse) {\n\t\t\t\tlegendItems.reverse();\n\t\t\t}\n\n\t\t\tme.legendItems = legendItems;\n\t\t},\n\t\tafterBuildLabels: noop,\n\n\t\t//\n\n\t\tbeforeFit: noop,\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar labelOpts = opts.labels;\n\t\t\tvar display = opts.display;\n\n\t\t\tvar ctx = me.ctx;\n\n\t\t\tvar globalDefault = Chart.defaults.global,\n\t\t\t\titemOrDefault = helpers.getValueOrDefault,\n\t\t\t\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n\t\t\t\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n\t\t\t\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n\t\t\t\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t\t// Reset hit boxes\n\t\t\tvar hitboxes = me.legendHitBoxes = [];\n\n\t\t\tvar minSize = me.minSize;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\tminSize.height = display ? 10 : 0;\n\t\t\t} else {\n\t\t\t\tminSize.width = display ? 10 : 0;\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Increase sizes here\n\t\t\tif (display) {\n\t\t\t\tctx.font = labelFont;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// Labels\n\n\t\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\n\n\t\t\t\t\tctx.textAlign = 'left';\n\t\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n\t\t\t\t\t\t\ttotalHeight += fontSize + (labelOpts.padding);\n\t\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t\t});\n\n\t\t\t\t\tminSize.height += totalHeight;\n\n\t\t\t\t} else {\n\t\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\t\tvar currentColWidth = 0;\n\t\t\t\t\tvar currentColHeight = 0;\n\t\t\t\t\tvar itemHeight = fontSize + vPadding;\n\n\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {\n\t\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\n\t\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Get max width\n\t\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\t\tcurrentColHeight += itemHeight;\n\n\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\n\t\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\t\tminSize.width += totalWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\t\tafterFit: noop,\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\n\t\t// Actually draw the legend on the canvas\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar labelOpts = opts.labels;\n\t\t\tvar globalDefault = Chart.defaults.global,\n\t\t\t\tlineDefault = globalDefault.elements.line,\n\t\t\t\tlegendWidth = me.width,\n\t\t\t\tlineWidths = me.lineWidths;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx,\n\t\t\t\t\tcursor,\n\t\t\t\t\titemOrDefault = helpers.getValueOrDefault,\n\t\t\t\t\tfontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),\n\t\t\t\t\tfontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n\t\t\t\t\tfontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n\t\t\t\t\tfontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n\t\t\t\t\tlabelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t\t\t// Canvas setup\n\t\t\t\tctx.textAlign = 'left';\n\t\t\t\tctx.textBaseline = 'top';\n\t\t\t\tctx.lineWidth = 0.5;\n\t\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\t\tctx.font = labelFont;\n\n\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize),\n\t\t\t\t\thitboxes = me.legendHitBoxes;\n\n\t\t\t\t// current position\n\t\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the ctx for the box\n\t\t\t\t\tctx.save();\n\n\t\t\t\t\tctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n\t\t\t\t\tctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\t\tctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\t\tctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\t\tctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\t\tctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n\t\t\t\t\tvar isLineWidthZero = (itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\n\n\t\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\t\tctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\n\t\t\t\t\t\tvar offSet = radius / Math.SQRT2;\n\t\t\t\t\t\tvar centerX = x + offSet;\n\t\t\t\t\t\tvar centerY = y + offSet;\n\n\t\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\t\tChart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\t\tif (!isLineWidthZero) {\n\t\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.restore();\n\t\t\t\t};\n\t\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\t\tctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);\n\n\t\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\t\tctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));\n\t\t\t\t\t\tctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Horizontal\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcursor = {\n\t\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\n\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\tline: 0\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcursor = {\n\t\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\tline: 0\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width,\n\t\t\t\t\t\twidth = boxWidth + (fontSize / 2) + textWidth,\n\t\t\t\t\t\tx = cursor.x,\n\t\t\t\t\t\ty = cursor.y;\n\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tif (x + width >= legendWidth) {\n\t\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (y + itemHeight > me.bottom) {\n\t\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t}\n\n\t\t\t\t\tdrawLegendBox(x, y, legendItem);\n\n\t\t\t\t\thitboxes[i].left = x;\n\t\t\t\t\thitboxes[i].top = y;\n\n\t\t\t\t\t// Fill the actual label\n\t\t\t\t\tfillText(x, y, legendItem, textWidth);\n\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tcursor.x += width + (labelOpts.padding);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @return {Boolean} true if a change occured\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\t\tvar changed = false;\n\n\t\t\tif (type === 'mousemove') {\n\t\t\t\tif (!opts.onHover) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (type === 'click') {\n\t\t\t\tif (!opts.onClick) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Chart event already has relative position in it\n\t\t\tvar x = e.x,\n\t\t\t\ty = e.y;\n\n\t\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t\t// See if we are touching one of the dataset boxes\n\t\t\t\tvar lh = me.legendHitBoxes;\n\t\t\t\tfor (var i = 0; i < lh.length; ++i) {\n\t\t\t\t\tvar hitBox = lh[i];\n\n\t\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t\t// Touching an element\n\t\t\t\t\t\tif (type === 'click') {\n\t\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\t\topts.onClick.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (type === 'mousemove') {\n\t\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\t\topts.onHover.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\tfunction createNewLegendAndAttach(chartInstance, legendOpts) {\n\t\tvar legend = new Chart.Legend({\n\t\t\tctx: chartInstance.chart.ctx,\n\t\t\toptions: legendOpts,\n\t\t\tchart: chartInstance\n\t\t});\n\t\tchartInstance.legend = legend;\n\t\tChart.layoutService.addBox(chartInstance, legend);\n\t}\n\n\t// Register the legend plugin\n\tChart.plugins.register({\n\t\tbeforeInit: function(chartInstance) {\n\t\t\tvar legendOpts = chartInstance.options.legend;\n\n\t\t\tif (legendOpts) {\n\t\t\t\tcreateNewLegendAndAttach(chartInstance, legendOpts);\n\t\t\t}\n\t\t},\n\t\tbeforeUpdate: function(chartInstance) {\n\t\t\tvar legendOpts = chartInstance.options.legend;\n\n\t\t\tif (legendOpts) {\n\t\t\t\tlegendOpts = helpers.configMerge(Chart.defaults.global.legend, legendOpts);\n\n\t\t\t\tif (chartInstance.legend) {\n\t\t\t\t\tchartInstance.legend.options = legendOpts;\n\t\t\t\t} else {\n\t\t\t\t\tcreateNewLegendAndAttach(chartInstance, legendOpts);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tChart.layoutService.removeBox(chartInstance, chartInstance.legend);\n\t\t\t\tdelete chartInstance.legend;\n\t\t\t}\n\t\t},\n\t\tafterEvent: function(chartInstance, e) {\n\t\t\tvar legend = chartInstance.legend;\n\t\t\tif (legend) {\n\t\t\t\tlegend.handleEvent(e);\n\t\t\t}\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}