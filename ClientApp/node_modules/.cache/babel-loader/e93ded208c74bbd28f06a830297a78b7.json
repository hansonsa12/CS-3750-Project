{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  var defaultConfig = {\n    position: 'left',\n    // label settings\n    ticks: {\n      callback: Chart.Ticks.formatters.logarithmic\n    }\n  };\n  var LogarithmicScale = Chart.Scale.extend({\n    determineDataLimits: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var chart = me.chart;\n      var data = chart.data;\n      var datasets = data.datasets;\n      var getValueOrDefault = helpers.getValueOrDefault;\n      var isHorizontal = me.isHorizontal();\n\n      function IDMatches(meta) {\n        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n      } // Calculate Range\n\n\n      me.min = null;\n      me.max = null;\n      me.minNotZero = null;\n      var hasStacks = opts.stacked;\n\n      if (hasStacks === undefined) {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          if (hasStacks) {\n            return;\n          }\n\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n            hasStacks = true;\n          }\n        });\n      }\n\n      if (opts.stacked || hasStacks) {\n        var valuesPerStack = {};\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n          var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            if (valuesPerStack[key] === undefined) {\n              valuesPerStack[key] = [];\n            }\n\n            helpers.each(dataset.data, function (rawValue, index) {\n              var values = valuesPerStack[key];\n              var value = +me.getRightValue(rawValue);\n\n              if (isNaN(value) || meta.data[index].hidden) {\n                return;\n              }\n\n              values[index] = values[index] || 0;\n\n              if (opts.relativePoints) {\n                values[index] = 100;\n              } else {\n                // Don't need to split positive and negative since the log scale can't handle a 0 crossing\n                values[index] += value;\n              }\n            });\n          }\n        });\n        helpers.each(valuesPerStack, function (valuesForType) {\n          var minVal = helpers.min(valuesForType);\n          var maxVal = helpers.max(valuesForType);\n          me.min = me.min === null ? minVal : Math.min(me.min, minVal);\n          me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n        });\n      } else {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            helpers.each(dataset.data, function (rawValue, index) {\n              var value = +me.getRightValue(rawValue);\n\n              if (isNaN(value) || meta.data[index].hidden) {\n                return;\n              }\n\n              if (me.min === null) {\n                me.min = value;\n              } else if (value < me.min) {\n                me.min = value;\n              }\n\n              if (me.max === null) {\n                me.max = value;\n              } else if (value > me.max) {\n                me.max = value;\n              }\n\n              if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n                me.minNotZero = value;\n              }\n            });\n          }\n        });\n      }\n\n      me.min = getValueOrDefault(tickOpts.min, me.min);\n      me.max = getValueOrDefault(tickOpts.max, me.max);\n\n      if (me.min === me.max) {\n        if (me.min !== 0 && me.min !== null) {\n          me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n          me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n        } else {\n          me.min = 1;\n          me.max = 10;\n        }\n      }\n    },\n    buildTicks: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var generationOptions = {\n        min: tickOpts.min,\n        max: tickOpts.max\n      };\n      var ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);\n\n      if (!me.isHorizontal()) {\n        // We are in a vertical orientation. The top value is the highest. So reverse the array\n        ticks.reverse();\n      } // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n\n      me.max = helpers.max(ticks);\n      me.min = helpers.min(ticks);\n\n      if (tickOpts.reverse) {\n        ticks.reverse();\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n    },\n    convertTicksToLabels: function () {\n      this.tickValues = this.ticks.slice();\n      Chart.Scale.prototype.convertTicksToLabels.call(this);\n    },\n    // Get the correct tooltip label\n    getLabelForIndex: function (index, datasetIndex) {\n      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    getPixelForTick: function (index) {\n      return this.getPixelForValue(this.tickValues[index]);\n    },\n    getPixelForValue: function (value) {\n      var me = this;\n      var innerDimension;\n      var pixel;\n      var start = me.start;\n      var newVal = +me.getRightValue(value);\n      var range;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n\n      if (me.isHorizontal()) {\n        range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\n\n        if (newVal === 0) {\n          pixel = me.left;\n        } else {\n          innerDimension = me.width;\n          pixel = me.left + innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));\n        }\n      } else {\n        // Bottom - top since pixels increase downward on a screen\n        innerDimension = me.height;\n\n        if (start === 0 && !tickOpts.reverse) {\n          range = helpers.log10(me.end) - helpers.log10(me.minNotZero);\n\n          if (newVal === start) {\n            pixel = me.bottom;\n          } else if (newVal === me.minNotZero) {\n            pixel = me.bottom - innerDimension * 0.02;\n          } else {\n            pixel = me.bottom - innerDimension * 0.02 - innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));\n          }\n        } else if (me.end === 0 && tickOpts.reverse) {\n          range = helpers.log10(me.start) - helpers.log10(me.minNotZero);\n\n          if (newVal === me.end) {\n            pixel = me.top;\n          } else if (newVal === me.minNotZero) {\n            pixel = me.top + innerDimension * 0.02;\n          } else {\n            pixel = me.top + innerDimension * 0.02 + innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));\n          }\n        } else {\n          range = helpers.log10(me.end) - helpers.log10(start);\n          innerDimension = me.height;\n          pixel = me.bottom - innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));\n        }\n      }\n\n      return pixel;\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var range = helpers.log10(me.end) - helpers.log10(me.start);\n      var value, innerDimension;\n\n      if (me.isHorizontal()) {\n        innerDimension = me.width;\n        value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);\n      } else {\n        // todo: if start === 0\n        innerDimension = me.height;\n        value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;\n      }\n\n      return value;\n    }\n  });\n  Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/scales/scale.logarithmic.js"],"names":["module","exports","Chart","helpers","defaultConfig","position","ticks","callback","Ticks","formatters","logarithmic","LogarithmicScale","Scale","extend","determineDataLimits","me","opts","options","tickOpts","chart","data","datasets","getValueOrDefault","isHorizontal","IDMatches","meta","xAxisID","id","yAxisID","min","max","minNotZero","hasStacks","stacked","undefined","each","dataset","datasetIndex","getDatasetMeta","isDatasetVisible","stack","valuesPerStack","key","type","join","rawValue","index","values","value","getRightValue","isNaN","hidden","relativePoints","valuesForType","minVal","maxVal","Math","pow","floor","log10","buildTicks","generationOptions","generators","reverse","start","end","convertTicksToLabels","tickValues","slice","prototype","call","getLabelForIndex","getPixelForTick","getPixelForValue","innerDimension","pixel","newVal","range","left","width","height","bottom","top","getValueForPixel","scaleService","registerScaleType"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tcallback: Chart.Ticks.formatters.logarithmic\n\t\t}\n\t};\n\n\tvar LogarithmicScale = Chart.Scale.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// Calculate Range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\t\tme.minNotZero = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tvalues[index] = 100;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Don't need to split positive and negative since the log scale can't handle a 0 crossing\n\t\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.min = getValueOrDefault(tickOpts.min, me.min);\n\t\t\tme.max = getValueOrDefault(tickOpts.max, me.max);\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tme.min = 1;\n\t\t\t\t\tme.max = 10;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\tvar generationOptions = {\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max\n\t\t\t};\n\t\t\tvar ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);\n\n\t\t\tif (!me.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tticks.reverse();\n\t\t\t}\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tthis.tickValues = this.ticks.slice();\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(this);\n\t\t},\n\t\t// Get the correct tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t},\n\t\tgetPixelForValue: function(value) {\n\t\t\tvar me = this;\n\t\t\tvar innerDimension;\n\t\t\tvar pixel;\n\n\t\t\tvar start = me.start;\n\t\t\tvar newVal = +me.getRightValue(value);\n\t\t\tvar range;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\n\t\t\t\tif (newVal === 0) {\n\t\t\t\t\tpixel = me.left;\n\t\t\t\t} else {\n\t\t\t\t\tinnerDimension = me.width;\n\t\t\t\t\tpixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Bottom - top since pixels increase downward on a screen\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tif (start === 0 && !tickOpts.reverse) {\n\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(me.minNotZero);\n\t\t\t\t\tif (newVal === start) {\n\t\t\t\t\t\tpixel = me.bottom;\n\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\tpixel = me.bottom - innerDimension * 0.02;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixel = me.bottom - innerDimension * 0.02 - (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\n\t\t\t\t\t}\n\t\t\t\t} else if (me.end === 0 && tickOpts.reverse) {\n\t\t\t\t\trange = helpers.log10(me.start) - helpers.log10(me.minNotZero);\n\t\t\t\t\tif (newVal === me.end) {\n\t\t\t\t\t\tpixel = me.top;\n\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\tpixel = me.top + innerDimension * 0.02;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixel = me.top + innerDimension * 0.02 + (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start);\n\t\t\t\t\tinnerDimension = me.height;\n\t\t\t\t\tpixel = me.bottom - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar range = helpers.log10(me.end) - helpers.log10(me.start);\n\t\t\tvar value, innerDimension;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tvalue = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);\n\t\t\t} else {  // todo: if start === 0\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tvalue = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n\n};\n"]},"metadata":{},"sourceType":"script"}