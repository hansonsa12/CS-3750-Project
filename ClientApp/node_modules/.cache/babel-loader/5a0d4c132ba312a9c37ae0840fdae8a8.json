{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var globalOpts = Chart.defaults.global;\n  globalOpts.elements.rectangle = {\n    backgroundColor: globalOpts.defaultColor,\n    borderWidth: 0,\n    borderColor: globalOpts.defaultColor,\n    borderSkipped: 'bottom'\n  };\n\n  function isVertical(bar) {\n    return bar._view.width !== undefined;\n  }\n  /**\n   * Helper function to get the bounds of the bar regardless of the orientation\n   * @private\n   * @param bar {Chart.Element.Rectangle} the bar\n   * @return {Bounds} bounds of the bar\n   */\n\n\n  function getBarBounds(bar) {\n    var vm = bar._view;\n    var x1, x2, y1, y2;\n\n    if (isVertical(bar)) {\n      // vertical\n      var halfWidth = vm.width / 2;\n      x1 = vm.x - halfWidth;\n      x2 = vm.x + halfWidth;\n      y1 = Math.min(vm.y, vm.base);\n      y2 = Math.max(vm.y, vm.base);\n    } else {\n      // horizontal bar\n      var halfHeight = vm.height / 2;\n      x1 = Math.min(vm.x, vm.base);\n      x2 = Math.max(vm.x, vm.base);\n      y1 = vm.y - halfHeight;\n      y2 = vm.y + halfHeight;\n    }\n\n    return {\n      left: x1,\n      top: y1,\n      right: x2,\n      bottom: y2\n    };\n  }\n\n  Chart.elements.Rectangle = Chart.Element.extend({\n    draw: function () {\n      var ctx = this._chart.ctx;\n      var vm = this._view;\n      var left, right, top, bottom, signX, signY, borderSkipped;\n      var borderWidth = vm.borderWidth;\n\n      if (!vm.horizontal) {\n        // bar\n        left = vm.x - vm.width / 2;\n        right = vm.x + vm.width / 2;\n        top = vm.y;\n        bottom = vm.base;\n        signX = 1;\n        signY = bottom > top ? 1 : -1;\n        borderSkipped = vm.borderSkipped || 'bottom';\n      } else {\n        // horizontal bar\n        left = vm.base;\n        right = vm.x;\n        top = vm.y - vm.height / 2;\n        bottom = vm.y + vm.height / 2;\n        signX = right > left ? 1 : -1;\n        signY = 1;\n        borderSkipped = vm.borderSkipped || 'left';\n      } // Canvas doesn't allow us to stroke inside the width so we can\n      // adjust the sizes to fit if we're setting a stroke on the line\n\n\n      if (borderWidth) {\n        // borderWidth shold be less than bar width and bar height.\n        var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n        borderWidth = borderWidth > barSize ? barSize : borderWidth;\n        var halfStroke = borderWidth / 2; // Adjust borderWidth when bar top position is near vm.base(zero).\n\n        var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\n        var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\n        var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\n        var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0); // not become a vertical line?\n\n        if (borderLeft !== borderRight) {\n          top = borderTop;\n          bottom = borderBottom;\n        } // not become a horizontal line?\n\n\n        if (borderTop !== borderBottom) {\n          left = borderLeft;\n          right = borderRight;\n        }\n      }\n\n      ctx.beginPath();\n      ctx.fillStyle = vm.backgroundColor;\n      ctx.strokeStyle = vm.borderColor;\n      ctx.lineWidth = borderWidth; // Corner points, from bottom-left to bottom-right clockwise\n      // | 1 2 |\n      // | 0 3 |\n\n      var corners = [[left, bottom], [left, top], [right, top], [right, bottom]]; // Find first (starting) corner with fallback to 'bottom'\n\n      var borders = ['bottom', 'left', 'top', 'right'];\n      var startCorner = borders.indexOf(borderSkipped, 0);\n\n      if (startCorner === -1) {\n        startCorner = 0;\n      }\n\n      function cornerAt(index) {\n        return corners[(startCorner + index) % 4];\n      } // Draw rectangle from 'startCorner'\n\n\n      var corner = cornerAt(0);\n      ctx.moveTo(corner[0], corner[1]);\n\n      for (var i = 1; i < 4; i++) {\n        corner = cornerAt(i);\n        ctx.lineTo(corner[0], corner[1]);\n      }\n\n      ctx.fill();\n\n      if (borderWidth) {\n        ctx.stroke();\n      }\n    },\n    height: function () {\n      var vm = this._view;\n      return vm.base - vm.y;\n    },\n    inRange: function (mouseX, mouseY) {\n      var inRange = false;\n\n      if (this._view) {\n        var bounds = getBarBounds(this);\n        inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n      }\n\n      return inRange;\n    },\n    inLabelRange: function (mouseX, mouseY) {\n      var me = this;\n\n      if (!me._view) {\n        return false;\n      }\n\n      var inRange = false;\n      var bounds = getBarBounds(me);\n\n      if (isVertical(me)) {\n        inRange = mouseX >= bounds.left && mouseX <= bounds.right;\n      } else {\n        inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n      }\n\n      return inRange;\n    },\n    inXRange: function (mouseX) {\n      var bounds = getBarBounds(this);\n      return mouseX >= bounds.left && mouseX <= bounds.right;\n    },\n    inYRange: function (mouseY) {\n      var bounds = getBarBounds(this);\n      return mouseY >= bounds.top && mouseY <= bounds.bottom;\n    },\n    getCenterPoint: function () {\n      var vm = this._view;\n      var x, y;\n\n      if (isVertical(this)) {\n        x = vm.x;\n        y = (vm.y + vm.base) / 2;\n      } else {\n        x = (vm.x + vm.base) / 2;\n        y = vm.y;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    getArea: function () {\n      var vm = this._view;\n      return vm.width * Math.abs(vm.y - vm.base);\n    },\n    tooltipPosition: function () {\n      var vm = this._view;\n      return {\n        x: vm.x,\n        y: vm.y\n      };\n    }\n  });\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/elements/element.rectangle.js"],"names":["module","exports","Chart","globalOpts","defaults","global","elements","rectangle","backgroundColor","defaultColor","borderWidth","borderColor","borderSkipped","isVertical","bar","_view","width","undefined","getBarBounds","vm","x1","x2","y1","y2","halfWidth","x","Math","min","y","base","max","halfHeight","height","left","top","right","bottom","Rectangle","Element","extend","draw","ctx","_chart","signX","signY","horizontal","barSize","abs","halfStroke","borderLeft","borderRight","borderTop","borderBottom","beginPath","fillStyle","strokeStyle","lineWidth","corners","borders","startCorner","indexOf","cornerAt","index","corner","moveTo","i","lineTo","fill","stroke","inRange","mouseX","mouseY","bounds","inLabelRange","me","inXRange","inYRange","getCenterPoint","getArea","tooltipPosition"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar globalOpts = Chart.defaults.global;\n\n\tglobalOpts.elements.rectangle = {\n\t\tbackgroundColor: globalOpts.defaultColor,\n\t\tborderWidth: 0,\n\t\tborderColor: globalOpts.defaultColor,\n\t\tborderSkipped: 'bottom'\n\t};\n\n\tfunction isVertical(bar) {\n\t\treturn bar._view.width !== undefined;\n\t}\n\n\t/**\n\t * Helper function to get the bounds of the bar regardless of the orientation\n\t * @private\n\t * @param bar {Chart.Element.Rectangle} the bar\n\t * @return {Bounds} bounds of the bar\n\t */\n\tfunction getBarBounds(bar) {\n\t\tvar vm = bar._view;\n\t\tvar x1, x2, y1, y2;\n\n\t\tif (isVertical(bar)) {\n\t\t\t// vertical\n\t\t\tvar halfWidth = vm.width / 2;\n\t\t\tx1 = vm.x - halfWidth;\n\t\t\tx2 = vm.x + halfWidth;\n\t\t\ty1 = Math.min(vm.y, vm.base);\n\t\t\ty2 = Math.max(vm.y, vm.base);\n\t\t} else {\n\t\t\t// horizontal bar\n\t\t\tvar halfHeight = vm.height / 2;\n\t\t\tx1 = Math.min(vm.x, vm.base);\n\t\t\tx2 = Math.max(vm.x, vm.base);\n\t\t\ty1 = vm.y - halfHeight;\n\t\t\ty2 = vm.y + halfHeight;\n\t\t}\n\n\t\treturn {\n\t\t\tleft: x1,\n\t\t\ttop: y1,\n\t\t\tright: x2,\n\t\t\tbottom: y2\n\t\t};\n\t}\n\n\tChart.elements.Rectangle = Chart.Element.extend({\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar left, right, top, bottom, signX, signY, borderSkipped;\n\t\t\tvar borderWidth = vm.borderWidth;\n\n\t\t\tif (!vm.horizontal) {\n\t\t\t\t// bar\n\t\t\t\tleft = vm.x - vm.width / 2;\n\t\t\t\tright = vm.x + vm.width / 2;\n\t\t\t\ttop = vm.y;\n\t\t\t\tbottom = vm.base;\n\t\t\t\tsignX = 1;\n\t\t\t\tsignY = bottom > top? 1: -1;\n\t\t\t\tborderSkipped = vm.borderSkipped || 'bottom';\n\t\t\t} else {\n\t\t\t\t// horizontal bar\n\t\t\t\tleft = vm.base;\n\t\t\t\tright = vm.x;\n\t\t\t\ttop = vm.y - vm.height / 2;\n\t\t\t\tbottom = vm.y + vm.height / 2;\n\t\t\t\tsignX = right > left? 1: -1;\n\t\t\t\tsignY = 1;\n\t\t\t\tborderSkipped = vm.borderSkipped || 'left';\n\t\t\t}\n\n\t\t\t// Canvas doesn't allow us to stroke inside the width so we can\n\t\t\t// adjust the sizes to fit if we're setting a stroke on the line\n\t\t\tif (borderWidth) {\n\t\t\t\t// borderWidth shold be less than bar width and bar height.\n\t\t\t\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n\t\t\t\tborderWidth = borderWidth > barSize? barSize: borderWidth;\n\t\t\t\tvar halfStroke = borderWidth / 2;\n\t\t\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\n\t\t\t\tvar borderLeft = left + (borderSkipped !== 'left'? halfStroke * signX: 0);\n\t\t\t\tvar borderRight = right + (borderSkipped !== 'right'? -halfStroke * signX: 0);\n\t\t\t\tvar borderTop = top + (borderSkipped !== 'top'? halfStroke * signY: 0);\n\t\t\t\tvar borderBottom = bottom + (borderSkipped !== 'bottom'? -halfStroke * signY: 0);\n\t\t\t\t// not become a vertical line?\n\t\t\t\tif (borderLeft !== borderRight) {\n\t\t\t\t\ttop = borderTop;\n\t\t\t\t\tbottom = borderBottom;\n\t\t\t\t}\n\t\t\t\t// not become a horizontal line?\n\t\t\t\tif (borderTop !== borderBottom) {\n\t\t\t\t\tleft = borderLeft;\n\t\t\t\t\tright = borderRight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tctx.fillStyle = vm.backgroundColor;\n\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\tctx.lineWidth = borderWidth;\n\n\t\t\t// Corner points, from bottom-left to bottom-right clockwise\n\t\t\t// | 1 2 |\n\t\t\t// | 0 3 |\n\t\t\tvar corners = [\n\t\t\t\t[left, bottom],\n\t\t\t\t[left, top],\n\t\t\t\t[right, top],\n\t\t\t\t[right, bottom]\n\t\t\t];\n\n\t\t\t// Find first (starting) corner with fallback to 'bottom'\n\t\t\tvar borders = ['bottom', 'left', 'top', 'right'];\n\t\t\tvar startCorner = borders.indexOf(borderSkipped, 0);\n\t\t\tif (startCorner === -1) {\n\t\t\t\tstartCorner = 0;\n\t\t\t}\n\n\t\t\tfunction cornerAt(index) {\n\t\t\t\treturn corners[(startCorner + index) % 4];\n\t\t\t}\n\n\t\t\t// Draw rectangle from 'startCorner'\n\t\t\tvar corner = cornerAt(0);\n\t\t\tctx.moveTo(corner[0], corner[1]);\n\n\t\t\tfor (var i = 1; i < 4; i++) {\n\t\t\t\tcorner = cornerAt(i);\n\t\t\t\tctx.lineTo(corner[0], corner[1]);\n\t\t\t}\n\n\t\t\tctx.fill();\n\t\t\tif (borderWidth) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\theight: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm.base - vm.y;\n\t\t},\n\t\tinRange: function(mouseX, mouseY) {\n\t\t\tvar inRange = false;\n\n\t\t\tif (this._view) {\n\t\t\t\tvar bounds = getBarBounds(this);\n\t\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t\t}\n\n\t\t\treturn inRange;\n\t\t},\n\t\tinLabelRange: function(mouseX, mouseY) {\n\t\t\tvar me = this;\n\t\t\tif (!me._view) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar inRange = false;\n\t\t\tvar bounds = getBarBounds(me);\n\n\t\t\tif (isVertical(me)) {\n\t\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t\t} else {\n\t\t\t\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t\t}\n\n\t\t\treturn inRange;\n\t\t},\n\t\tinXRange: function(mouseX) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\treturn mouseX >= bounds.left && mouseX <= bounds.right;\n\t\t},\n\t\tinYRange: function(mouseY) {\n\t\t\tvar bounds = getBarBounds(this);\n\t\t\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\n\t\t},\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\tvar x, y;\n\t\t\tif (isVertical(this)) {\n\t\t\t\tx = vm.x;\n\t\t\t\ty = (vm.y + vm.base) / 2;\n\t\t\t} else {\n\t\t\t\tx = (vm.x + vm.base) / 2;\n\t\t\t\ty = vm.y;\n\t\t\t}\n\n\t\t\treturn {x: x, y: y};\n\t\t},\n\t\tgetArea: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm.width * Math.abs(vm.y - vm.base);\n\t\t},\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\t\t}\n\t});\n\n};\n"]},"metadata":{},"sourceType":"script"}