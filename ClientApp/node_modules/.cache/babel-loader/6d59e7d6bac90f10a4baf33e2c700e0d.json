{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  var defaultConfig = {\n    position: 'left',\n    ticks: {\n      callback: Chart.Ticks.formatters.linear\n    }\n  };\n  var LinearScale = Chart.LinearScaleBase.extend({\n    determineDataLimits: function () {\n      var me = this;\n      var opts = me.options;\n      var chart = me.chart;\n      var data = chart.data;\n      var datasets = data.datasets;\n      var isHorizontal = me.isHorizontal();\n\n      function IDMatches(meta) {\n        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n      } // First Calculate the range\n\n\n      me.min = null;\n      me.max = null;\n      var hasStacks = opts.stacked;\n\n      if (hasStacks === undefined) {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          if (hasStacks) {\n            return;\n          }\n\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n            hasStacks = true;\n          }\n        });\n      }\n\n      if (opts.stacked || hasStacks) {\n        var valuesPerStack = {};\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n          var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');\n\n          if (valuesPerStack[key] === undefined) {\n            valuesPerStack[key] = {\n              positiveValues: [],\n              negativeValues: []\n            };\n          } // Store these per type\n\n\n          var positiveValues = valuesPerStack[key].positiveValues;\n          var negativeValues = valuesPerStack[key].negativeValues;\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            helpers.each(dataset.data, function (rawValue, index) {\n              var value = +me.getRightValue(rawValue);\n\n              if (isNaN(value) || meta.data[index].hidden) {\n                return;\n              }\n\n              positiveValues[index] = positiveValues[index] || 0;\n              negativeValues[index] = negativeValues[index] || 0;\n\n              if (opts.relativePoints) {\n                positiveValues[index] = 100;\n              } else if (value < 0) {\n                negativeValues[index] += value;\n              } else {\n                positiveValues[index] += value;\n              }\n            });\n          }\n        });\n        helpers.each(valuesPerStack, function (valuesForType) {\n          var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n          var minVal = helpers.min(values);\n          var maxVal = helpers.max(values);\n          me.min = me.min === null ? minVal : Math.min(me.min, minVal);\n          me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n        });\n      } else {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            helpers.each(dataset.data, function (rawValue, index) {\n              var value = +me.getRightValue(rawValue);\n\n              if (isNaN(value) || meta.data[index].hidden) {\n                return;\n              }\n\n              if (me.min === null) {\n                me.min = value;\n              } else if (value < me.min) {\n                me.min = value;\n              }\n\n              if (me.max === null) {\n                me.max = value;\n              } else if (value > me.max) {\n                me.max = value;\n              }\n            });\n          }\n        });\n      } // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\n\n      this.handleTickRangeOptions();\n    },\n    getTickLimit: function () {\n      var maxTicks;\n      var me = this;\n      var tickOpts = me.options.ticks;\n\n      if (me.isHorizontal()) {\n        maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n      } else {\n        // The factor of 2 used to scale the font size has been experimentally determined.\n        var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);\n        maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n      }\n\n      return maxTicks;\n    },\n    // Called after the ticks are built. We need\n    handleDirectionalChanges: function () {\n      if (!this.isHorizontal()) {\n        // We are in a vertical orientation. The top value is the highest. So reverse the array\n        this.ticks.reverse();\n      }\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    // Utils\n    getPixelForValue: function (value) {\n      // This must be called after fit has been run so that\n      // this.left, this.top, this.right, and this.bottom have been defined\n      var me = this;\n      var start = me.start;\n      var rightValue = +me.getRightValue(value);\n      var pixel;\n      var range = me.end - start;\n\n      if (me.isHorizontal()) {\n        pixel = me.left + me.width / range * (rightValue - start);\n        return Math.round(pixel);\n      }\n\n      pixel = me.bottom - me.height / range * (rightValue - start);\n      return Math.round(pixel);\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var isHorizontal = me.isHorizontal();\n      var innerDimension = isHorizontal ? me.width : me.height;\n      var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n      return me.start + (me.end - me.start) * offset;\n    },\n    getPixelForTick: function (index) {\n      return this.getPixelForValue(this.ticksAsNumbers[index]);\n    }\n  });\n  Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/scales/scale.linear.js"],"names":["module","exports","Chart","helpers","defaultConfig","position","ticks","callback","Ticks","formatters","linear","LinearScale","LinearScaleBase","extend","determineDataLimits","me","opts","options","chart","data","datasets","isHorizontal","IDMatches","meta","xAxisID","id","yAxisID","min","max","hasStacks","stacked","undefined","each","dataset","datasetIndex","getDatasetMeta","isDatasetVisible","stack","valuesPerStack","key","type","join","positiveValues","negativeValues","rawValue","index","value","getRightValue","isNaN","hidden","relativePoints","valuesForType","values","concat","minVal","maxVal","Math","handleTickRangeOptions","getTickLimit","maxTicks","tickOpts","maxTicksLimit","ceil","width","tickFontSize","getValueOrDefault","fontSize","defaults","global","defaultFontSize","height","handleDirectionalChanges","reverse","getLabelForIndex","getPixelForValue","start","rightValue","pixel","range","end","left","round","bottom","getValueForPixel","innerDimension","offset","getPixelForTick","ticksAsNumbers","scaleService","registerScaleType"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,UAASC,KAAT,EAAgB;AAEhC,MAAIC,OAAO,GAAGD,KAAK,CAACC,OAApB;AAEA,MAAIC,aAAa,GAAG;AACnBC,IAAAA,QAAQ,EAAE,MADS;AAEnBC,IAAAA,KAAK,EAAE;AACNC,MAAAA,QAAQ,EAAEL,KAAK,CAACM,KAAN,CAAYC,UAAZ,CAAuBC;AAD3B;AAFY,GAApB;AAOA,MAAIC,WAAW,GAAGT,KAAK,CAACU,eAAN,CAAsBC,MAAtB,CAA6B;AAC9CC,IAAAA,mBAAmB,EAAE,YAAW;AAC/B,UAAIC,EAAE,GAAG,IAAT;AACA,UAAIC,IAAI,GAAGD,EAAE,CAACE,OAAd;AACA,UAAIC,KAAK,GAAGH,EAAE,CAACG,KAAf;AACA,UAAIC,IAAI,GAAGD,KAAK,CAACC,IAAjB;AACA,UAAIC,QAAQ,GAAGD,IAAI,CAACC,QAApB;AACA,UAAIC,YAAY,GAAGN,EAAE,CAACM,YAAH,EAAnB;;AAEA,eAASC,SAAT,CAAmBC,IAAnB,EAAyB;AACxB,eAAOF,YAAY,GAAGE,IAAI,CAACC,OAAL,KAAiBT,EAAE,CAACU,EAAvB,GAA4BF,IAAI,CAACG,OAAL,KAAiBX,EAAE,CAACU,EAAnE;AACA,OAV8B,CAY/B;;;AACAV,MAAAA,EAAE,CAACY,GAAH,GAAS,IAAT;AACAZ,MAAAA,EAAE,CAACa,GAAH,GAAS,IAAT;AAEA,UAAIC,SAAS,GAAGb,IAAI,CAACc,OAArB;;AACA,UAAID,SAAS,KAAKE,SAAlB,EAA6B;AAC5B5B,QAAAA,OAAO,CAAC6B,IAAR,CAAaZ,QAAb,EAAuB,UAASa,OAAT,EAAkBC,YAAlB,EAAgC;AACtD,cAAIL,SAAJ,EAAe;AACd;AACA;;AAED,cAAIN,IAAI,GAAGL,KAAK,CAACiB,cAAN,CAAqBD,YAArB,CAAX;;AACA,cAAIhB,KAAK,CAACkB,gBAAN,CAAuBF,YAAvB,KAAwCZ,SAAS,CAACC,IAAD,CAAjD,IACHA,IAAI,CAACc,KAAL,KAAeN,SADhB,EAC2B;AAC1BF,YAAAA,SAAS,GAAG,IAAZ;AACA;AACD,SAVD;AAWA;;AAED,UAAIb,IAAI,CAACc,OAAL,IAAgBD,SAApB,EAA+B;AAC9B,YAAIS,cAAc,GAAG,EAArB;AAEAnC,QAAAA,OAAO,CAAC6B,IAAR,CAAaZ,QAAb,EAAuB,UAASa,OAAT,EAAkBC,YAAlB,EAAgC;AACtD,cAAIX,IAAI,GAAGL,KAAK,CAACiB,cAAN,CAAqBD,YAArB,CAAX;AACA,cAAIK,GAAG,GAAG,CACThB,IAAI,CAACiB,IADI,EAET;AACExB,UAAAA,IAAI,CAACc,OAAL,KAAiBC,SAAjB,IAA8BR,IAAI,CAACc,KAAL,KAAeN,SAA9C,GAA2DG,YAA3D,GAA0E,EAHlE,EAITX,IAAI,CAACc,KAJI,EAKRI,IALQ,CAKH,GALG,CAAV;;AAOA,cAAIH,cAAc,CAACC,GAAD,CAAd,KAAwBR,SAA5B,EAAuC;AACtCO,YAAAA,cAAc,CAACC,GAAD,CAAd,GAAsB;AACrBG,cAAAA,cAAc,EAAE,EADK;AAErBC,cAAAA,cAAc,EAAE;AAFK,aAAtB;AAIA,WAdqD,CAgBtD;;;AACA,cAAID,cAAc,GAAGJ,cAAc,CAACC,GAAD,CAAd,CAAoBG,cAAzC;AACA,cAAIC,cAAc,GAAGL,cAAc,CAACC,GAAD,CAAd,CAAoBI,cAAzC;;AAEA,cAAIzB,KAAK,CAACkB,gBAAN,CAAuBF,YAAvB,KAAwCZ,SAAS,CAACC,IAAD,CAArD,EAA6D;AAC5DpB,YAAAA,OAAO,CAAC6B,IAAR,CAAaC,OAAO,CAACd,IAArB,EAA2B,UAASyB,QAAT,EAAmBC,KAAnB,EAA0B;AACpD,kBAAIC,KAAK,GAAG,CAAC/B,EAAE,CAACgC,aAAH,CAAiBH,QAAjB,CAAb;;AACA,kBAAII,KAAK,CAACF,KAAD,CAAL,IAAgBvB,IAAI,CAACJ,IAAL,CAAU0B,KAAV,EAAiBI,MAArC,EAA6C;AAC5C;AACA;;AAEDP,cAAAA,cAAc,CAACG,KAAD,CAAd,GAAwBH,cAAc,CAACG,KAAD,CAAd,IAAyB,CAAjD;AACAF,cAAAA,cAAc,CAACE,KAAD,CAAd,GAAwBF,cAAc,CAACE,KAAD,CAAd,IAAyB,CAAjD;;AAEA,kBAAI7B,IAAI,CAACkC,cAAT,EAAyB;AACxBR,gBAAAA,cAAc,CAACG,KAAD,CAAd,GAAwB,GAAxB;AACA,eAFD,MAEO,IAAIC,KAAK,GAAG,CAAZ,EAAe;AACrBH,gBAAAA,cAAc,CAACE,KAAD,CAAd,IAAyBC,KAAzB;AACA,eAFM,MAEA;AACNJ,gBAAAA,cAAc,CAACG,KAAD,CAAd,IAAyBC,KAAzB;AACA;AACD,aAhBD;AAiBA;AACD,SAvCD;AAyCA3C,QAAAA,OAAO,CAAC6B,IAAR,CAAaM,cAAb,EAA6B,UAASa,aAAT,EAAwB;AACpD,cAAIC,MAAM,GAAGD,aAAa,CAACT,cAAd,CAA6BW,MAA7B,CAAoCF,aAAa,CAACR,cAAlD,CAAb;AACA,cAAIW,MAAM,GAAGnD,OAAO,CAACwB,GAAR,CAAYyB,MAAZ,CAAb;AACA,cAAIG,MAAM,GAAGpD,OAAO,CAACyB,GAAR,CAAYwB,MAAZ,CAAb;AACArC,UAAAA,EAAE,CAACY,GAAH,GAASZ,EAAE,CAACY,GAAH,KAAW,IAAX,GAAkB2B,MAAlB,GAA2BE,IAAI,CAAC7B,GAAL,CAASZ,EAAE,CAACY,GAAZ,EAAiB2B,MAAjB,CAApC;AACAvC,UAAAA,EAAE,CAACa,GAAH,GAASb,EAAE,CAACa,GAAH,KAAW,IAAX,GAAkB2B,MAAlB,GAA2BC,IAAI,CAAC5B,GAAL,CAASb,EAAE,CAACa,GAAZ,EAAiB2B,MAAjB,CAApC;AACA,SAND;AAQA,OApDD,MAoDO;AACNpD,QAAAA,OAAO,CAAC6B,IAAR,CAAaZ,QAAb,EAAuB,UAASa,OAAT,EAAkBC,YAAlB,EAAgC;AACtD,cAAIX,IAAI,GAAGL,KAAK,CAACiB,cAAN,CAAqBD,YAArB,CAAX;;AACA,cAAIhB,KAAK,CAACkB,gBAAN,CAAuBF,YAAvB,KAAwCZ,SAAS,CAACC,IAAD,CAArD,EAA6D;AAC5DpB,YAAAA,OAAO,CAAC6B,IAAR,CAAaC,OAAO,CAACd,IAArB,EAA2B,UAASyB,QAAT,EAAmBC,KAAnB,EAA0B;AACpD,kBAAIC,KAAK,GAAG,CAAC/B,EAAE,CAACgC,aAAH,CAAiBH,QAAjB,CAAb;;AACA,kBAAII,KAAK,CAACF,KAAD,CAAL,IAAgBvB,IAAI,CAACJ,IAAL,CAAU0B,KAAV,EAAiBI,MAArC,EAA6C;AAC5C;AACA;;AAED,kBAAIlC,EAAE,CAACY,GAAH,KAAW,IAAf,EAAqB;AACpBZ,gBAAAA,EAAE,CAACY,GAAH,GAASmB,KAAT;AACA,eAFD,MAEO,IAAIA,KAAK,GAAG/B,EAAE,CAACY,GAAf,EAAoB;AAC1BZ,gBAAAA,EAAE,CAACY,GAAH,GAASmB,KAAT;AACA;;AAED,kBAAI/B,EAAE,CAACa,GAAH,KAAW,IAAf,EAAqB;AACpBb,gBAAAA,EAAE,CAACa,GAAH,GAASkB,KAAT;AACA,eAFD,MAEO,IAAIA,KAAK,GAAG/B,EAAE,CAACa,GAAf,EAAoB;AAC1Bb,gBAAAA,EAAE,CAACa,GAAH,GAASkB,KAAT;AACA;AACD,aAjBD;AAkBA;AACD,SAtBD;AAuBA,OA3G8B,CA6G/B;;;AACA,WAAKW,sBAAL;AACA,KAhH6C;AAiH9CC,IAAAA,YAAY,EAAE,YAAW;AACxB,UAAIC,QAAJ;AACA,UAAI5C,EAAE,GAAG,IAAT;AACA,UAAI6C,QAAQ,GAAG7C,EAAE,CAACE,OAAH,CAAWX,KAA1B;;AAEA,UAAIS,EAAE,CAACM,YAAH,EAAJ,EAAuB;AACtBsC,QAAAA,QAAQ,GAAGH,IAAI,CAAC7B,GAAL,CAASiC,QAAQ,CAACC,aAAT,GAAyBD,QAAQ,CAACC,aAAlC,GAAkD,EAA3D,EAA+DL,IAAI,CAACM,IAAL,CAAU/C,EAAE,CAACgD,KAAH,GAAW,EAArB,CAA/D,CAAX;AACA,OAFD,MAEO;AACN;AACA,YAAIC,YAAY,GAAG7D,OAAO,CAAC8D,iBAAR,CAA0BL,QAAQ,CAACM,QAAnC,EAA6ChE,KAAK,CAACiE,QAAN,CAAeC,MAAf,CAAsBC,eAAnE,CAAnB;AACAV,QAAAA,QAAQ,GAAGH,IAAI,CAAC7B,GAAL,CAASiC,QAAQ,CAACC,aAAT,GAAyBD,QAAQ,CAACC,aAAlC,GAAkD,EAA3D,EAA+DL,IAAI,CAACM,IAAL,CAAU/C,EAAE,CAACuD,MAAH,IAAa,IAAIN,YAAjB,CAAV,CAA/D,CAAX;AACA;;AAED,aAAOL,QAAP;AACA,KA/H6C;AAgI9C;AACAY,IAAAA,wBAAwB,EAAE,YAAW;AACpC,UAAI,CAAC,KAAKlD,YAAL,EAAL,EAA0B;AACzB;AACA,aAAKf,KAAL,CAAWkE,OAAX;AACA;AACD,KAtI6C;AAuI9CC,IAAAA,gBAAgB,EAAE,UAAS5B,KAAT,EAAgBX,YAAhB,EAA8B;AAC/C,aAAO,CAAC,KAAKa,aAAL,CAAmB,KAAK7B,KAAL,CAAWC,IAAX,CAAgBC,QAAhB,CAAyBc,YAAzB,EAAuCf,IAAvC,CAA4C0B,KAA5C,CAAnB,CAAR;AACA,KAzI6C;AA0I9C;AACA6B,IAAAA,gBAAgB,EAAE,UAAS5B,KAAT,EAAgB;AACjC;AACA;AACA,UAAI/B,EAAE,GAAG,IAAT;AACA,UAAI4D,KAAK,GAAG5D,EAAE,CAAC4D,KAAf;AAEA,UAAIC,UAAU,GAAG,CAAC7D,EAAE,CAACgC,aAAH,CAAiBD,KAAjB,CAAlB;AACA,UAAI+B,KAAJ;AACA,UAAIC,KAAK,GAAG/D,EAAE,CAACgE,GAAH,GAASJ,KAArB;;AAEA,UAAI5D,EAAE,CAACM,YAAH,EAAJ,EAAuB;AACtBwD,QAAAA,KAAK,GAAG9D,EAAE,CAACiE,IAAH,GAAWjE,EAAE,CAACgD,KAAH,GAAWe,KAAX,IAAoBF,UAAU,GAAGD,KAAjC,CAAnB;AACA,eAAOnB,IAAI,CAACyB,KAAL,CAAWJ,KAAX,CAAP;AACA;;AAEDA,MAAAA,KAAK,GAAG9D,EAAE,CAACmE,MAAH,GAAanE,EAAE,CAACuD,MAAH,GAAYQ,KAAZ,IAAqBF,UAAU,GAAGD,KAAlC,CAArB;AACA,aAAOnB,IAAI,CAACyB,KAAL,CAAWJ,KAAX,CAAP;AACA,KA5J6C;AA6J9CM,IAAAA,gBAAgB,EAAE,UAASN,KAAT,EAAgB;AACjC,UAAI9D,EAAE,GAAG,IAAT;AACA,UAAIM,YAAY,GAAGN,EAAE,CAACM,YAAH,EAAnB;AACA,UAAI+D,cAAc,GAAG/D,YAAY,GAAGN,EAAE,CAACgD,KAAN,GAAchD,EAAE,CAACuD,MAAlD;AACA,UAAIe,MAAM,GAAG,CAAChE,YAAY,GAAGwD,KAAK,GAAG9D,EAAE,CAACiE,IAAd,GAAqBjE,EAAE,CAACmE,MAAH,GAAYL,KAA9C,IAAuDO,cAApE;AACA,aAAOrE,EAAE,CAAC4D,KAAH,GAAY,CAAC5D,EAAE,CAACgE,GAAH,GAAShE,EAAE,CAAC4D,KAAb,IAAsBU,MAAzC;AACA,KAnK6C;AAoK9CC,IAAAA,eAAe,EAAE,UAASzC,KAAT,EAAgB;AAChC,aAAO,KAAK6B,gBAAL,CAAsB,KAAKa,cAAL,CAAoB1C,KAApB,CAAtB,CAAP;AACA;AAtK6C,GAA7B,CAAlB;AAwKA3C,EAAAA,KAAK,CAACsF,YAAN,CAAmBC,iBAAnB,CAAqC,QAArC,EAA+C9E,WAA/C,EAA4DP,aAA5D;AAEA,CArLD","sourcesContent":["'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\t\tticks: {\n\t\t\tcallback: Chart.Ticks.formatters.linear\n\t\t}\n\t};\n\n\tvar LinearScale = Chart.LinearScaleBase.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// First Calculate the range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\tvaluesPerStack[key] = {\n\t\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store these per type\n\t\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\n\t\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\t\tvar minVal = helpers.min(values);\n\t\t\t\t\tvar maxVal = helpers.max(values);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar maxTicks;\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n\t\t\t} else {\n\t\t\t\t// The factor of 2 used to scale the font size has been experimentally determined.\n\t\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);\n\t\t\t\tmaxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n\t\t\t}\n\n\t\t\treturn maxTicks;\n\t\t},\n\t\t// Called after the ticks are built. We need\n\t\thandleDirectionalChanges: function() {\n\t\t\tif (!this.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tthis.ticks.reverse();\n\t\t\t}\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\t// Utils\n\t\tgetPixelForValue: function(value) {\n\t\t\t// This must be called after fit has been run so that\n\t\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\t\tvar me = this;\n\t\t\tvar start = me.start;\n\n\t\t\tvar rightValue = +me.getRightValue(value);\n\t\t\tvar pixel;\n\t\t\tvar range = me.end - start;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tpixel = me.left + (me.width / range * (rightValue - start));\n\t\t\t\treturn Math.round(pixel);\n\t\t\t}\n\n\t\t\tpixel = me.bottom - (me.height / range * (rightValue - start));\n\t\t\treturn Math.round(pixel);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar innerDimension = isHorizontal ? me.width : me.height;\n\t\t\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n\t\t\treturn me.start + ((me.end - me.start) * offset);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n\n};\n"]},"metadata":{},"sourceType":"script"}