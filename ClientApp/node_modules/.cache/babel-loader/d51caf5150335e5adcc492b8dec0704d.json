{"ast":null,"code":"/* global window: false */\n'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  Chart.defaults.global.animation = {\n    duration: 1000,\n    easing: 'easeOutQuart',\n    onProgress: helpers.noop,\n    onComplete: helpers.noop\n  };\n  Chart.Animation = Chart.Element.extend({\n    currentStep: null,\n    // the current animation step\n    numSteps: 60,\n    // default number of steps\n    easing: '',\n    // the easing to use for this animation\n    render: null,\n    // render function used by the animation service\n    onAnimationProgress: null,\n    // user specified callback to fire on each step of the animation\n    onAnimationComplete: null // user specified callback to fire when the animation finishes\n\n  });\n  Chart.animationService = {\n    frameDuration: 17,\n    animations: [],\n    dropFrames: 0,\n    request: null,\n\n    /**\n     * @function Chart.animationService.addAnimation\n     * @param chartInstance {ChartController} the chart to animate\n     * @param animationObject {IAnimation} the animation that we will animate\n     * @param duration {Number} length of animation in ms\n     * @param lazy {Boolean} if true, the chart is not marked as animating to enable more responsive interactions\n     */\n    addAnimation: function (chartInstance, animationObject, duration, lazy) {\n      var me = this;\n\n      if (!lazy) {\n        chartInstance.animating = true;\n      }\n\n      for (var index = 0; index < me.animations.length; ++index) {\n        if (me.animations[index].chartInstance === chartInstance) {\n          // replacing an in progress animation\n          me.animations[index].animationObject = animationObject;\n          return;\n        }\n      }\n\n      me.animations.push({\n        chartInstance: chartInstance,\n        animationObject: animationObject\n      }); // If there are no animations queued, manually kickstart a digest, for lack of a better word\n\n      if (me.animations.length === 1) {\n        me.requestAnimationFrame();\n      }\n    },\n    // Cancel the animation for a given chart instance\n    cancelAnimation: function (chartInstance) {\n      var index = helpers.findIndex(this.animations, function (animationWrapper) {\n        return animationWrapper.chartInstance === chartInstance;\n      });\n\n      if (index !== -1) {\n        this.animations.splice(index, 1);\n        chartInstance.animating = false;\n      }\n    },\n    requestAnimationFrame: function () {\n      var me = this;\n\n      if (me.request === null) {\n        // Skip animation frame requests until the active one is executed.\n        // This can happen when processing mouse events, e.g. 'mousemove'\n        // and 'mouseout' events will trigger multiple renders.\n        me.request = helpers.requestAnimFrame.call(window, function () {\n          me.request = null;\n          me.startDigest();\n        });\n      }\n    },\n    startDigest: function () {\n      var me = this;\n      var startTime = Date.now();\n      var framesToDrop = 0;\n\n      if (me.dropFrames > 1) {\n        framesToDrop = Math.floor(me.dropFrames);\n        me.dropFrames = me.dropFrames % 1;\n      }\n\n      var i = 0;\n\n      while (i < me.animations.length) {\n        if (me.animations[i].animationObject.currentStep === null) {\n          me.animations[i].animationObject.currentStep = 0;\n        }\n\n        me.animations[i].animationObject.currentStep += 1 + framesToDrop;\n\n        if (me.animations[i].animationObject.currentStep > me.animations[i].animationObject.numSteps) {\n          me.animations[i].animationObject.currentStep = me.animations[i].animationObject.numSteps;\n        }\n\n        me.animations[i].animationObject.render(me.animations[i].chartInstance, me.animations[i].animationObject);\n\n        if (me.animations[i].animationObject.onAnimationProgress && me.animations[i].animationObject.onAnimationProgress.call) {\n          me.animations[i].animationObject.onAnimationProgress.call(me.animations[i].chartInstance, me.animations[i]);\n        }\n\n        if (me.animations[i].animationObject.currentStep === me.animations[i].animationObject.numSteps) {\n          if (me.animations[i].animationObject.onAnimationComplete && me.animations[i].animationObject.onAnimationComplete.call) {\n            me.animations[i].animationObject.onAnimationComplete.call(me.animations[i].chartInstance, me.animations[i]);\n          } // executed the last frame. Remove the animation.\n\n\n          me.animations[i].chartInstance.animating = false;\n          me.animations.splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n\n      var endTime = Date.now();\n      var dropFrames = (endTime - startTime) / me.frameDuration;\n      me.dropFrames += dropFrames; // Do we have more stuff to animate?\n\n      if (me.animations.length > 0) {\n        me.requestAnimationFrame();\n      }\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/core/core.animation.js"],"names":["module","exports","Chart","helpers","defaults","global","animation","duration","easing","onProgress","noop","onComplete","Animation","Element","extend","currentStep","numSteps","render","onAnimationProgress","onAnimationComplete","animationService","frameDuration","animations","dropFrames","request","addAnimation","chartInstance","animationObject","lazy","me","animating","index","length","push","requestAnimationFrame","cancelAnimation","findIndex","animationWrapper","splice","requestAnimFrame","call","window","startDigest","startTime","Date","now","framesToDrop","Math","floor","i","endTime"],"mappings":"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","sourcesContent":["/* global window: false */\n'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.global.animation = {\n\t\tduration: 1000,\n\t\teasing: 'easeOutQuart',\n\t\tonProgress: helpers.noop,\n\t\tonComplete: helpers.noop\n\t};\n\n\tChart.Animation = Chart.Element.extend({\n\t\tcurrentStep: null, // the current animation step\n\t\tnumSteps: 60, // default number of steps\n\t\teasing: '', // the easing to use for this animation\n\t\trender: null, // render function used by the animation service\n\n\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\n\t\tonAnimationComplete: null // user specified callback to fire when the animation finishes\n\t});\n\n\tChart.animationService = {\n\t\tframeDuration: 17,\n\t\tanimations: [],\n\t\tdropFrames: 0,\n\t\trequest: null,\n\n\t\t/**\n\t\t * @function Chart.animationService.addAnimation\n\t\t * @param chartInstance {ChartController} the chart to animate\n\t\t * @param animationObject {IAnimation} the animation that we will animate\n\t\t * @param duration {Number} length of animation in ms\n\t\t * @param lazy {Boolean} if true, the chart is not marked as animating to enable more responsive interactions\n\t\t */\n\t\taddAnimation: function(chartInstance, animationObject, duration, lazy) {\n\t\t\tvar me = this;\n\n\t\t\tif (!lazy) {\n\t\t\t\tchartInstance.animating = true;\n\t\t\t}\n\n\t\t\tfor (var index = 0; index < me.animations.length; ++index) {\n\t\t\t\tif (me.animations[index].chartInstance === chartInstance) {\n\t\t\t\t\t// replacing an in progress animation\n\t\t\t\t\tme.animations[index].animationObject = animationObject;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.animations.push({\n\t\t\t\tchartInstance: chartInstance,\n\t\t\t\tanimationObject: animationObject\n\t\t\t});\n\n\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\t\tif (me.animations.length === 1) {\n\t\t\t\tme.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\t\t// Cancel the animation for a given chart instance\n\t\tcancelAnimation: function(chartInstance) {\n\t\t\tvar index = helpers.findIndex(this.animations, function(animationWrapper) {\n\t\t\t\treturn animationWrapper.chartInstance === chartInstance;\n\t\t\t});\n\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.animations.splice(index, 1);\n\t\t\t\tchartInstance.animating = false;\n\t\t\t}\n\t\t},\n\t\trequestAnimationFrame: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.request === null) {\n\t\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {\n\t\t\t\t\tme.request = null;\n\t\t\t\t\tme.startDigest();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tstartDigest: function() {\n\t\t\tvar me = this;\n\n\t\t\tvar startTime = Date.now();\n\t\t\tvar framesToDrop = 0;\n\n\t\t\tif (me.dropFrames > 1) {\n\t\t\t\tframesToDrop = Math.floor(me.dropFrames);\n\t\t\t\tme.dropFrames = me.dropFrames % 1;\n\t\t\t}\n\n\t\t\tvar i = 0;\n\t\t\twhile (i < me.animations.length) {\n\t\t\t\tif (me.animations[i].animationObject.currentStep === null) {\n\t\t\t\t\tme.animations[i].animationObject.currentStep = 0;\n\t\t\t\t}\n\n\t\t\t\tme.animations[i].animationObject.currentStep += 1 + framesToDrop;\n\n\t\t\t\tif (me.animations[i].animationObject.currentStep > me.animations[i].animationObject.numSteps) {\n\t\t\t\t\tme.animations[i].animationObject.currentStep = me.animations[i].animationObject.numSteps;\n\t\t\t\t}\n\n\t\t\t\tme.animations[i].animationObject.render(me.animations[i].chartInstance, me.animations[i].animationObject);\n\t\t\t\tif (me.animations[i].animationObject.onAnimationProgress && me.animations[i].animationObject.onAnimationProgress.call) {\n\t\t\t\t\tme.animations[i].animationObject.onAnimationProgress.call(me.animations[i].chartInstance, me.animations[i]);\n\t\t\t\t}\n\n\t\t\t\tif (me.animations[i].animationObject.currentStep === me.animations[i].animationObject.numSteps) {\n\t\t\t\t\tif (me.animations[i].animationObject.onAnimationComplete && me.animations[i].animationObject.onAnimationComplete.call) {\n\t\t\t\t\t\tme.animations[i].animationObject.onAnimationComplete.call(me.animations[i].chartInstance, me.animations[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// executed the last frame. Remove the animation.\n\t\t\t\t\tme.animations[i].chartInstance.animating = false;\n\n\t\t\t\t\tme.animations.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar endTime = Date.now();\n\t\t\tvar dropFrames = (endTime - startTime) / me.frameDuration;\n\n\t\t\tme.dropFrames += dropFrames;\n\n\t\t\t// Do we have more stuff to animate?\n\t\t\tif (me.animations.length > 0) {\n\t\t\t\tme.requestAnimationFrame();\n\t\t\t}\n\t\t}\n\t};\n};\n"]},"metadata":{},"sourceType":"script"}