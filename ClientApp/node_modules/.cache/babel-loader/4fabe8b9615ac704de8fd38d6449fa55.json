{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  /**\n   * Helper function to get relative position for an event\n   * @param {Event|IEvent} event - The event to get the position for\n   * @param {Chart} chart - The chart\n   * @returns {Point} the event position\n   */\n\n  function getRelativePosition(e, chart) {\n    if (e.native) {\n      return {\n        x: e.x,\n        y: e.y\n      };\n    }\n\n    return helpers.getRelativePosition(e, chart);\n  }\n  /**\n   * Helper function to traverse all of the visible elements in the chart\n   * @param chart {chart} the chart\n   * @param handler {Function} the callback to execute for each visible item\n   */\n\n\n  function parseVisibleItems(chart, handler) {\n    var datasets = chart.data.datasets;\n    var meta, i, j, ilen, jlen;\n\n    for (i = 0, ilen = datasets.length; i < ilen; ++i) {\n      if (!chart.isDatasetVisible(i)) {\n        continue;\n      }\n\n      meta = chart.getDatasetMeta(i);\n\n      for (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n        var element = meta.data[j];\n\n        if (!element._view.skip) {\n          handler(element);\n        }\n      }\n    }\n  }\n  /**\n   * Helper function to get the items that intersect the event position\n   * @param items {ChartElement[]} elements to filter\n   * @param position {Point} the point to be nearest to\n   * @return {ChartElement[]} the nearest items\n   */\n\n\n  function getIntersectItems(chart, position) {\n    var elements = [];\n    parseVisibleItems(chart, function (element) {\n      if (element.inRange(position.x, position.y)) {\n        elements.push(element);\n      }\n    });\n    return elements;\n  }\n  /**\n   * Helper function to get the items nearest to the event position considering all visible items in teh chart\n   * @param chart {Chart} the chart to look at elements from\n   * @param position {Point} the point to be nearest to\n   * @param intersect {Boolean} if true, only consider items that intersect the position\n   * @param distanceMetric {Function} Optional function to provide the distance between\n   * @return {ChartElement[]} the nearest items\n   */\n\n\n  function getNearestItems(chart, position, intersect, distanceMetric) {\n    var minDistance = Number.POSITIVE_INFINITY;\n    var nearestItems = [];\n\n    if (!distanceMetric) {\n      distanceMetric = helpers.distanceBetweenPoints;\n    }\n\n    parseVisibleItems(chart, function (element) {\n      if (intersect && !element.inRange(position.x, position.y)) {\n        return;\n      }\n\n      var center = element.getCenterPoint();\n      var distance = distanceMetric(position, center);\n\n      if (distance < minDistance) {\n        nearestItems = [element];\n        minDistance = distance;\n      } else if (distance === minDistance) {\n        // Can have multiple items at the same distance in which case we sort by size\n        nearestItems.push(element);\n      }\n    });\n    return nearestItems;\n  }\n\n  function indexMode(chart, e, options) {\n    var position = getRelativePosition(e, chart.chart);\n\n    var distanceMetric = function (pt1, pt2) {\n      return Math.abs(pt1.x - pt2.x);\n    };\n\n    var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n    var elements = [];\n\n    if (!items.length) {\n      return [];\n    }\n\n    chart.data.datasets.forEach(function (dataset, datasetIndex) {\n      if (chart.isDatasetVisible(datasetIndex)) {\n        var meta = chart.getDatasetMeta(datasetIndex),\n            element = meta.data[items[0]._index]; // don't count items that are skipped (null data)\n\n        if (element && !element._view.skip) {\n          elements.push(element);\n        }\n      }\n    });\n    return elements;\n  }\n  /**\n   * @interface IInteractionOptions\n   */\n\n  /**\n   * If true, only consider items that intersect the point\n   * @name IInterfaceOptions#boolean\n   * @type Boolean\n   */\n\n  /**\n   * Contains interaction related functions\n   * @namespace Chart.Interaction\n   */\n\n\n  Chart.Interaction = {\n    // Helper function for different modes\n    modes: {\n      single: function (chart, e) {\n        var position = getRelativePosition(e, chart.chart);\n        var elements = [];\n        parseVisibleItems(chart, function (element) {\n          if (element.inRange(position.x, position.y)) {\n            elements.push(element);\n            return elements;\n          }\n        });\n        return elements.slice(0, 1);\n      },\n\n      /**\n       * @function Chart.Interaction.modes.label\n       * @deprecated since version 2.4.0\n       */\n      label: indexMode,\n\n      /**\n       * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n       * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n       * @function Chart.Interaction.modes.index\n       * @since v2.4.0\n       * @param chart {chart} the chart we are returning items from\n       * @param e {Event} the event we are find things at\n       * @param options {IInteractionOptions} options to use during interaction\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n      index: indexMode,\n\n      /**\n       * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n       * If the options.intersect is false, we find the nearest item and return the items in that dataset\n       * @function Chart.Interaction.modes.dataset\n       * @param chart {chart} the chart we are returning items from\n       * @param e {Event} the event we are find things at\n       * @param options {IInteractionOptions} options to use during interaction\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n      dataset: function (chart, e, options) {\n        var position = getRelativePosition(e, chart.chart);\n        var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);\n\n        if (items.length > 0) {\n          items = chart.getDatasetMeta(items[0]._datasetIndex).data;\n        }\n\n        return items;\n      },\n\n      /**\n       * @function Chart.Interaction.modes.x-axis\n       * @deprecated since version 2.4.0. Use index mode and intersect == true\n       */\n      'x-axis': function (chart, e) {\n        return indexMode(chart, e, true);\n      },\n\n      /**\n       * Point mode returns all elements that hit test based on the event position\n       * of the event\n       * @function Chart.Interaction.modes.intersect\n       * @param chart {chart} the chart we are returning items from\n       * @param e {Event} the event we are find things at\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n      point: function (chart, e) {\n        var position = getRelativePosition(e, chart.chart);\n        return getIntersectItems(chart, position);\n      },\n\n      /**\n       * nearest mode returns the element closest to the point\n       * @function Chart.Interaction.modes.intersect\n       * @param chart {chart} the chart we are returning items from\n       * @param e {Event} the event we are find things at\n       * @param options {IInteractionOptions} options to use\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n      nearest: function (chart, e, options) {\n        var position = getRelativePosition(e, chart.chart);\n        var nearestItems = getNearestItems(chart, position, options.intersect); // We have multiple items at the same distance from the event. Now sort by smallest\n\n        if (nearestItems.length > 1) {\n          nearestItems.sort(function (a, b) {\n            var sizeA = a.getArea();\n            var sizeB = b.getArea();\n            var ret = sizeA - sizeB;\n\n            if (ret === 0) {\n              // if equal sort by dataset index\n              ret = a._datasetIndex - b._datasetIndex;\n            }\n\n            return ret;\n          });\n        } // Return only 1 item\n\n\n        return nearestItems.slice(0, 1);\n      },\n\n      /**\n       * x mode returns the elements that hit-test at the current x coordinate\n       * @function Chart.Interaction.modes.x\n       * @param chart {chart} the chart we are returning items from\n       * @param e {Event} the event we are find things at\n       * @param options {IInteractionOptions} options to use\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n      x: function (chart, e, options) {\n        var position = getRelativePosition(e, chart.chart);\n        var items = [];\n        var intersectsItem = false;\n        parseVisibleItems(chart, function (element) {\n          if (element.inXRange(position.x)) {\n            items.push(element);\n          }\n\n          if (element.inRange(position.x, position.y)) {\n            intersectsItem = true;\n          }\n        }); // If we want to trigger on an intersect and we don't have any items\n        // that intersect the position, return nothing\n\n        if (options.intersect && !intersectsItem) {\n          items = [];\n        }\n\n        return items;\n      },\n\n      /**\n       * y mode returns the elements that hit-test at the current y coordinate\n       * @function Chart.Interaction.modes.y\n       * @param chart {chart} the chart we are returning items from\n       * @param e {Event} the event we are find things at\n       * @param options {IInteractionOptions} options to use\n       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n       */\n      y: function (chart, e, options) {\n        var position = getRelativePosition(e, chart.chart);\n        var items = [];\n        var intersectsItem = false;\n        parseVisibleItems(chart, function (element) {\n          if (element.inYRange(position.y)) {\n            items.push(element);\n          }\n\n          if (element.inRange(position.x, position.y)) {\n            intersectsItem = true;\n          }\n        }); // If we want to trigger on an intersect and we don't have any items\n        // that intersect the position, return nothing\n\n        if (options.intersect && !intersectsItem) {\n          items = [];\n        }\n\n        return items;\n      }\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/core/core.interaction.js"],"names":["module","exports","Chart","helpers","getRelativePosition","e","chart","native","x","y","parseVisibleItems","handler","datasets","data","meta","i","j","ilen","jlen","length","isDatasetVisible","getDatasetMeta","element","_view","skip","getIntersectItems","position","elements","inRange","push","getNearestItems","intersect","distanceMetric","minDistance","Number","POSITIVE_INFINITY","nearestItems","distanceBetweenPoints","center","getCenterPoint","distance","indexMode","options","pt1","pt2","Math","abs","items","forEach","dataset","datasetIndex","_index","Interaction","modes","single","slice","label","index","_datasetIndex","point","nearest","sort","a","b","sizeA","getArea","sizeB","ret","intersectsItem","inXRange","inYRange"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(Chart) {\n\tvar helpers = Chart.helpers;\n\n\t/**\n\t * Helper function to get relative position for an event\n\t * @param {Event|IEvent} event - The event to get the position for\n\t * @param {Chart} chart - The chart\n\t * @returns {Point} the event position\n\t */\n\tfunction getRelativePosition(e, chart) {\n\t\tif (e.native) {\n\t\t\treturn {\n\t\t\t\tx: e.x,\n\t\t\t\ty: e.y\n\t\t\t};\n\t\t}\n\n\t\treturn helpers.getRelativePosition(e, chart);\n\t}\n\n\t/**\n\t * Helper function to traverse all of the visible elements in the chart\n\t * @param chart {chart} the chart\n\t * @param handler {Function} the callback to execute for each visible item\n\t */\n\tfunction parseVisibleItems(chart, handler) {\n\t\tvar datasets = chart.data.datasets;\n\t\tvar meta, i, j, ilen, jlen;\n\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\t\tvar element = meta.data[j];\n\t\t\t\tif (!element._view.skip) {\n\t\t\t\t\thandler(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper function to get the items that intersect the event position\n\t * @param items {ChartElement[]} elements to filter\n\t * @param position {Point} the point to be nearest to\n\t * @return {ChartElement[]} the nearest items\n\t */\n\tfunction getIntersectItems(chart, position) {\n\t\tvar elements = [];\n\n\t\tparseVisibleItems(chart, function(element) {\n\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t});\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Helper function to get the items nearest to the event position considering all visible items in teh chart\n\t * @param chart {Chart} the chart to look at elements from\n\t * @param position {Point} the point to be nearest to\n\t * @param intersect {Boolean} if true, only consider items that intersect the position\n\t * @param distanceMetric {Function} Optional function to provide the distance between\n\t * @return {ChartElement[]} the nearest items\n\t */\n\tfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\tvar nearestItems = [];\n\n\t\tif (!distanceMetric) {\n\t\t\tdistanceMetric = helpers.distanceBetweenPoints;\n\t\t}\n\n\t\tparseVisibleItems(chart, function(element) {\n\t\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar center = element.getCenterPoint();\n\t\t\tvar distance = distanceMetric(position, center);\n\n\t\t\tif (distance < minDistance) {\n\t\t\t\tnearestItems = [element];\n\t\t\t\tminDistance = distance;\n\t\t\t} else if (distance === minDistance) {\n\t\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\t\tnearestItems.push(element);\n\t\t\t}\n\t\t});\n\n\t\treturn nearestItems;\n\t}\n\n\tfunction indexMode(chart, e, options) {\n\t\tvar position = getRelativePosition(e, chart.chart);\n\t\tvar distanceMetric = function(pt1, pt2) {\n\t\t\treturn Math.abs(pt1.x - pt2.x);\n\t\t};\n\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\t\tvar elements = [];\n\n\t\tif (!items.length) {\n\t\t\treturn [];\n\t\t}\n\n\t\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\n\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex),\n\t\t\t\t\telement = meta.data[items[0]._index];\n\n\t\t\t\t// don't count items that are skipped (null data)\n\t\t\t\tif (element && !element._view.skip) {\n\t\t\t\t\telements.push(element);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * @interface IInteractionOptions\n\t */\n\t/**\n\t * If true, only consider items that intersect the point\n\t * @name IInterfaceOptions#boolean\n\t * @type Boolean\n\t */\n\n\t/**\n\t * Contains interaction related functions\n\t * @namespace Chart.Interaction\n\t */\n\tChart.Interaction = {\n\t\t// Helper function for different modes\n\t\tmodes: {\n\t\t\tsingle: function(chart, e) {\n\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\tvar elements = [];\n\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\telements.push(element);\n\t\t\t\t\t\treturn elements;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn elements.slice(0, 1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @function Chart.Interaction.modes.label\n\t\t\t * @deprecated since version 2.4.0\n\t\t\t */\n\t\t\tlabel: indexMode,\n\n\t\t\t/**\n\t\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t\t * @function Chart.Interaction.modes.index\n\t\t\t * @since v2.4.0\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tindex: indexMode,\n\n\t\t\t/**\n\t\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t\t * @function Chart.Interaction.modes.dataset\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use during interaction\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tdataset: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);\n\n\t\t\t\tif (items.length > 0) {\n\t\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t\t}\n\n\t\t\t\treturn items;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @function Chart.Interaction.modes.x-axis\n\t\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\n\t\t\t */\n\t\t\t'x-axis': function(chart, e) {\n\t\t\t\treturn indexMode(chart, e, true);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Point mode returns all elements that hit test based on the event position\n\t\t\t * of the event\n\t\t\t * @function Chart.Interaction.modes.intersect\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tpoint: function(chart, e) {\n\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\treturn getIntersectItems(chart, position);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * nearest mode returns the element closest to the point\n\t\t\t * @function Chart.Interaction.modes.intersect\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tnearest: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\tvar nearestItems = getNearestItems(chart, position, options.intersect);\n\n\t\t\t\t// We have multiple items at the same distance from the event. Now sort by smallest\n\t\t\t\tif (nearestItems.length > 1) {\n\t\t\t\t\tnearestItems.sort(function(a, b) {\n\t\t\t\t\t\tvar sizeA = a.getArea();\n\t\t\t\t\t\tvar sizeB = b.getArea();\n\t\t\t\t\t\tvar ret = sizeA - sizeB;\n\n\t\t\t\t\t\tif (ret === 0) {\n\t\t\t\t\t\t\t// if equal sort by dataset index\n\t\t\t\t\t\t\tret = a._datasetIndex - b._datasetIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Return only 1 item\n\t\t\t\treturn nearestItems.slice(0, 1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t\t * @function Chart.Interaction.modes.x\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tx: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\tvar items = [];\n\t\t\t\tvar intersectsItem = false;\n\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\tintersectsItem = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t\t// that intersect the position, return nothing\n\t\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\t\titems = [];\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t\t * @function Chart.Interaction.modes.y\n\t\t\t * @param chart {chart} the chart we are returning items from\n\t\t\t * @param e {Event} the event we are find things at\n\t\t\t * @param options {IInteractionOptions} options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\ty: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart.chart);\n\t\t\t\tvar items = [];\n\t\t\t\tvar intersectsItem = false;\n\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\tintersectsItem = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t\t// that intersect the position, return nothing\n\t\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\t\titems = [];\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t}\n\t\t}\n\t};\n};\n"]},"metadata":{},"sourceType":"script"}