{"ast":null,"code":"/* global window: false */\n'use strict';\n\nvar moment = require('moment');\n\nmoment = typeof moment === 'function' ? moment : window.moment;\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  var time = {\n    units: [{\n      name: 'millisecond',\n      steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n    }, {\n      name: 'second',\n      steps: [1, 2, 5, 10, 30]\n    }, {\n      name: 'minute',\n      steps: [1, 2, 5, 10, 30]\n    }, {\n      name: 'hour',\n      steps: [1, 2, 3, 6, 12]\n    }, {\n      name: 'day',\n      steps: [1, 2, 5]\n    }, {\n      name: 'week',\n      maxStep: 4\n    }, {\n      name: 'month',\n      maxStep: 3\n    }, {\n      name: 'quarter',\n      maxStep: 4\n    }, {\n      name: 'year',\n      maxStep: false\n    }]\n  };\n  var defaultConfig = {\n    position: 'bottom',\n    time: {\n      parser: false,\n      // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n      format: false,\n      // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n      unit: false,\n      // false == automatic or override with week, month, year, etc.\n      round: false,\n      // none, or override with week, month, year, etc.\n      displayFormat: false,\n      // DEPRECATED\n      isoWeekday: false,\n      // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n      minUnit: 'millisecond',\n      // defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n      displayFormats: {\n        millisecond: 'h:mm:ss.SSS a',\n        // 11:20:01.123 AM,\n        second: 'h:mm:ss a',\n        // 11:20:01 AM\n        minute: 'h:mm:ss a',\n        // 11:20:01 AM\n        hour: 'MMM D, hA',\n        // Sept 4, 5PM\n        day: 'll',\n        // Sep 4 2015\n        week: 'll',\n        // Week 46, or maybe \"[W]WW - YYYY\" ?\n        month: 'MMM YYYY',\n        // Sept 2015\n        quarter: '[Q]Q - YYYY',\n        // Q3\n        year: 'YYYY' // 2015\n\n      }\n    },\n    ticks: {\n      autoSkip: false\n    }\n  };\n  var TimeScale = Chart.Scale.extend({\n    initialize: function () {\n      if (!moment) {\n        throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n      }\n\n      Chart.Scale.prototype.initialize.call(this);\n    },\n    getLabelMoment: function (datasetIndex, index) {\n      if (datasetIndex === null || index === null) {\n        return null;\n      }\n\n      if (typeof this.labelMoments[datasetIndex] !== 'undefined') {\n        return this.labelMoments[datasetIndex][index];\n      }\n\n      return null;\n    },\n    getLabelDiff: function (datasetIndex, index) {\n      var me = this;\n\n      if (datasetIndex === null || index === null) {\n        return null;\n      }\n\n      if (me.labelDiffs === undefined) {\n        me.buildLabelDiffs();\n      }\n\n      if (typeof me.labelDiffs[datasetIndex] !== 'undefined') {\n        return me.labelDiffs[datasetIndex][index];\n      }\n\n      return null;\n    },\n    getMomentStartOf: function (tick) {\n      var me = this;\n\n      if (me.options.time.unit === 'week' && me.options.time.isoWeekday !== false) {\n        return tick.clone().startOf('isoWeek').isoWeekday(me.options.time.isoWeekday);\n      }\n\n      return tick.clone().startOf(me.tickUnit);\n    },\n    determineDataLimits: function () {\n      var me = this;\n      me.labelMoments = []; // Only parse these once. If the dataset does not have data as x,y pairs, we will use\n      // these\n\n      var scaleLabelMoments = [];\n\n      if (me.chart.data.labels && me.chart.data.labels.length > 0) {\n        helpers.each(me.chart.data.labels, function (label) {\n          var labelMoment = me.parseTime(label);\n\n          if (labelMoment.isValid()) {\n            if (me.options.time.round) {\n              labelMoment.startOf(me.options.time.round);\n            }\n\n            scaleLabelMoments.push(labelMoment);\n          }\n        }, me);\n        me.firstTick = moment.min.call(me, scaleLabelMoments);\n        me.lastTick = moment.max.call(me, scaleLabelMoments);\n      } else {\n        me.firstTick = null;\n        me.lastTick = null;\n      }\n\n      helpers.each(me.chart.data.datasets, function (dataset, datasetIndex) {\n        var momentsForDataset = [];\n        var datasetVisible = me.chart.isDatasetVisible(datasetIndex);\n\n        if (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\n          helpers.each(dataset.data, function (value) {\n            var labelMoment = me.parseTime(me.getRightValue(value));\n\n            if (labelMoment.isValid()) {\n              if (me.options.time.round) {\n                labelMoment.startOf(me.options.time.round);\n              }\n\n              momentsForDataset.push(labelMoment);\n\n              if (datasetVisible) {\n                // May have gone outside the scale ranges, make sure we keep the first and last ticks updated\n                me.firstTick = me.firstTick !== null ? moment.min(me.firstTick, labelMoment) : labelMoment;\n                me.lastTick = me.lastTick !== null ? moment.max(me.lastTick, labelMoment) : labelMoment;\n              }\n            }\n          }, me);\n        } else {\n          // We have no labels. Use the ones from the scale\n          momentsForDataset = scaleLabelMoments;\n        }\n\n        me.labelMoments.push(momentsForDataset);\n      }, me); // Set these after we've done all the data\n\n      if (me.options.time.min) {\n        me.firstTick = me.parseTime(me.options.time.min);\n      }\n\n      if (me.options.time.max) {\n        me.lastTick = me.parseTime(me.options.time.max);\n      } // We will modify these, so clone for later\n\n\n      me.firstTick = (me.firstTick || moment()).clone();\n      me.lastTick = (me.lastTick || moment()).clone();\n    },\n    buildLabelDiffs: function () {\n      var me = this;\n      me.labelDiffs = [];\n      var scaleLabelDiffs = []; // Parse common labels once\n\n      if (me.chart.data.labels && me.chart.data.labels.length > 0) {\n        helpers.each(me.chart.data.labels, function (label) {\n          var labelMoment = me.parseTime(label);\n\n          if (labelMoment.isValid()) {\n            if (me.options.time.round) {\n              labelMoment.startOf(me.options.time.round);\n            }\n\n            scaleLabelDiffs.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\n          }\n        }, me);\n      }\n\n      helpers.each(me.chart.data.datasets, function (dataset) {\n        var diffsForDataset = [];\n\n        if (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\n          helpers.each(dataset.data, function (value) {\n            var labelMoment = me.parseTime(me.getRightValue(value));\n\n            if (labelMoment.isValid()) {\n              if (me.options.time.round) {\n                labelMoment.startOf(me.options.time.round);\n              }\n\n              diffsForDataset.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\n            }\n          }, me);\n        } else {\n          // We have no labels. Use common ones\n          diffsForDataset = scaleLabelDiffs;\n        }\n\n        me.labelDiffs.push(diffsForDataset);\n      }, me);\n    },\n    buildTicks: function () {\n      var me = this;\n      me.ctx.save();\n      var tickFontSize = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);\n      var tickFontStyle = helpers.getValueOrDefault(me.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);\n      var tickFontFamily = helpers.getValueOrDefault(me.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);\n      var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n      me.ctx.font = tickLabelFont;\n      me.ticks = [];\n      me.unitScale = 1; // How much we scale the unit by, ie 2 means 2x unit per step\n\n      me.scaleSizeInUnits = 0; // How large the scale is in the base unit (seconds, minutes, etc)\n      // Set unit override if applicable\n\n      if (me.options.time.unit) {\n        me.tickUnit = me.options.time.unit || 'day';\n        me.displayFormat = me.options.time.displayFormats[me.tickUnit];\n        me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n        me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, 1);\n      } else {\n        // Determine the smallest needed unit of the time\n        var innerWidth = me.isHorizontal() ? me.width : me.height; // Crude approximation of what the label length might be\n\n        var tempFirstLabel = me.tickFormatFunction(me.firstTick, 0, []);\n        var tickLabelWidth = me.ctx.measureText(tempFirstLabel).width;\n        var cosRotation = Math.cos(helpers.toRadians(me.options.ticks.maxRotation));\n        var sinRotation = Math.sin(helpers.toRadians(me.options.ticks.maxRotation));\n        tickLabelWidth = tickLabelWidth * cosRotation + tickFontSize * sinRotation;\n        var labelCapacity = innerWidth / tickLabelWidth; // Start as small as possible\n\n        me.tickUnit = me.options.time.minUnit;\n        me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n        me.displayFormat = me.options.time.displayFormats[me.tickUnit];\n        var unitDefinitionIndex = 0;\n        var unitDefinition = time.units[unitDefinitionIndex]; // While we aren't ideal and we don't have units left\n\n        while (unitDefinitionIndex < time.units.length) {\n          // Can we scale this unit. If `false` we can scale infinitely\n          me.unitScale = 1;\n\n          if (helpers.isArray(unitDefinition.steps) && Math.ceil(me.scaleSizeInUnits / labelCapacity) < helpers.max(unitDefinition.steps)) {\n            // Use one of the predefined steps\n            for (var idx = 0; idx < unitDefinition.steps.length; ++idx) {\n              if (unitDefinition.steps[idx] >= Math.ceil(me.scaleSizeInUnits / labelCapacity)) {\n                me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, unitDefinition.steps[idx]);\n                break;\n              }\n            }\n\n            break;\n          } else if (unitDefinition.maxStep === false || Math.ceil(me.scaleSizeInUnits / labelCapacity) < unitDefinition.maxStep) {\n            // We have a max step. Scale this unit\n            me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, Math.ceil(me.scaleSizeInUnits / labelCapacity));\n            break;\n          } else {\n            // Move to the next unit up\n            ++unitDefinitionIndex;\n            unitDefinition = time.units[unitDefinitionIndex];\n            me.tickUnit = unitDefinition.name;\n            var leadingUnitBuffer = me.firstTick.diff(me.getMomentStartOf(me.firstTick), me.tickUnit, true);\n            var trailingUnitBuffer = me.getMomentStartOf(me.lastTick.clone().add(1, me.tickUnit)).diff(me.lastTick, me.tickUnit, true);\n            me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;\n            me.displayFormat = me.options.time.displayFormats[unitDefinition.name];\n          }\n        }\n      }\n\n      var roundedStart; // Only round the first tick if we have no hard minimum\n\n      if (!me.options.time.min) {\n        me.firstTick = me.getMomentStartOf(me.firstTick);\n        roundedStart = me.firstTick;\n      } else {\n        roundedStart = me.getMomentStartOf(me.firstTick);\n      } // Only round the last tick if we have no hard maximum\n\n\n      if (!me.options.time.max) {\n        var roundedEnd = me.getMomentStartOf(me.lastTick);\n        var delta = roundedEnd.diff(me.lastTick, me.tickUnit, true);\n\n        if (delta < 0) {\n          // Do not use end of because we need me to be in the next time unit\n          me.lastTick = me.getMomentStartOf(me.lastTick.add(1, me.tickUnit));\n        } else if (delta >= 0) {\n          me.lastTick = roundedEnd;\n        }\n\n        me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n      } // Tick displayFormat override\n\n\n      if (me.options.time.displayFormat) {\n        me.displayFormat = me.options.time.displayFormat;\n      } // first tick. will have been rounded correctly if options.time.min is not specified\n\n\n      me.ticks.push(me.firstTick.clone()); // For every unit in between the first and last moment, create a moment and add it to the ticks tick\n\n      for (var i = me.unitScale; i <= me.scaleSizeInUnits; i += me.unitScale) {\n        var newTick = roundedStart.clone().add(i, me.tickUnit); // Are we greater than the max time\n\n        if (me.options.time.max && newTick.diff(me.lastTick, me.tickUnit, true) >= 0) {\n          break;\n        }\n\n        me.ticks.push(newTick);\n      } // Always show the right tick\n\n\n      var diff = me.ticks[me.ticks.length - 1].diff(me.lastTick, me.tickUnit);\n\n      if (diff !== 0 || me.scaleSizeInUnits === 0) {\n        // this is a weird case. If the <max> option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart\n        // but the last tick was not rounded.\n        if (me.options.time.max) {\n          me.ticks.push(me.lastTick.clone());\n          me.scaleSizeInUnits = me.lastTick.diff(me.ticks[0], me.tickUnit, true);\n        } else {\n          me.ticks.push(me.lastTick.clone());\n          me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n        }\n      }\n\n      me.ctx.restore(); // Invalidate label diffs cache\n\n      me.labelDiffs = undefined;\n    },\n    // Get tooltip label\n    getLabelForIndex: function (index, datasetIndex) {\n      var me = this;\n      var label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';\n      var value = me.chart.data.datasets[datasetIndex].data[index];\n\n      if (value !== null && typeof value === 'object') {\n        label = me.getRightValue(value);\n      } // Format nicely\n\n\n      if (me.options.time.tooltipFormat) {\n        label = me.parseTime(label).format(me.options.time.tooltipFormat);\n      }\n\n      return label;\n    },\n    // Function to format an individual tick mark\n    tickFormatFunction: function (tick, index, ticks) {\n      var formattedTick = tick.format(this.displayFormat);\n      var tickOpts = this.options.ticks;\n      var callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\n      if (callback) {\n        return callback(formattedTick, index, ticks);\n      }\n\n      return formattedTick;\n    },\n    convertTicksToLabels: function () {\n      var me = this;\n      me.tickMoments = me.ticks;\n      me.ticks = me.ticks.map(me.tickFormatFunction, me);\n    },\n    getPixelForValue: function (value, index, datasetIndex) {\n      var me = this;\n      var offset = null;\n\n      if (index !== undefined && datasetIndex !== undefined) {\n        offset = me.getLabelDiff(datasetIndex, index);\n      }\n\n      if (offset === null) {\n        if (!value || !value.isValid) {\n          // not already a moment object\n          value = me.parseTime(me.getRightValue(value));\n        }\n\n        if (value && value.isValid && value.isValid()) {\n          offset = value.diff(me.firstTick, me.tickUnit, true);\n        }\n      }\n\n      if (offset !== null) {\n        var decimal = offset !== 0 ? offset / me.scaleSizeInUnits : offset;\n\n        if (me.isHorizontal()) {\n          var valueOffset = me.width * decimal;\n          return me.left + Math.round(valueOffset);\n        }\n\n        var heightOffset = me.height * decimal;\n        return me.top + Math.round(heightOffset);\n      }\n    },\n    getPixelForTick: function (index) {\n      return this.getPixelForValue(this.tickMoments[index], null, null);\n    },\n    getValueForPixel: function (pixel) {\n      var me = this;\n      var innerDimension = me.isHorizontal() ? me.width : me.height;\n      var offset = (pixel - (me.isHorizontal() ? me.left : me.top)) / innerDimension;\n      offset *= me.scaleSizeInUnits;\n      return me.firstTick.clone().add(moment.duration(offset, me.tickUnit).asSeconds(), 'seconds');\n    },\n    parseTime: function (label) {\n      var me = this;\n\n      if (typeof me.options.time.parser === 'string') {\n        return moment(label, me.options.time.parser);\n      }\n\n      if (typeof me.options.time.parser === 'function') {\n        return me.options.time.parser(label);\n      } // Date objects\n\n\n      if (typeof label.getMonth === 'function' || typeof label === 'number') {\n        return moment(label);\n      } // Moment support\n\n\n      if (label.isValid && label.isValid()) {\n        return label;\n      } // Custom parsing (return an instance of moment)\n\n\n      if (typeof me.options.time.format !== 'string' && me.options.time.format.call) {\n        console.warn('options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale');\n        return me.options.time.format(label);\n      } // Moment format parsing\n\n\n      return moment(label, me.options.time.format);\n    }\n  });\n  Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/scales/scale.time.js"],"names":["moment","require","window","module","exports","Chart","helpers","time","units","name","steps","maxStep","defaultConfig","position","parser","format","unit","round","displayFormat","isoWeekday","minUnit","displayFormats","millisecond","second","minute","hour","day","week","month","quarter","year","ticks","autoSkip","TimeScale","Scale","extend","initialize","Error","prototype","call","getLabelMoment","datasetIndex","index","labelMoments","getLabelDiff","me","labelDiffs","undefined","buildLabelDiffs","getMomentStartOf","tick","options","clone","startOf","tickUnit","determineDataLimits","scaleLabelMoments","chart","data","labels","length","each","label","labelMoment","parseTime","isValid","push","firstTick","min","lastTick","max","datasets","dataset","momentsForDataset","datasetVisible","isDatasetVisible","value","getRightValue","scaleLabelDiffs","diff","diffsForDataset","buildTicks","ctx","save","tickFontSize","getValueOrDefault","fontSize","defaults","global","defaultFontSize","tickFontStyle","fontStyle","defaultFontStyle","tickFontFamily","fontFamily","defaultFontFamily","tickLabelFont","fontString","font","unitScale","scaleSizeInUnits","unitStepSize","innerWidth","isHorizontal","width","height","tempFirstLabel","tickFormatFunction","tickLabelWidth","measureText","cosRotation","Math","cos","toRadians","maxRotation","sinRotation","sin","labelCapacity","unitDefinitionIndex","unitDefinition","isArray","ceil","idx","leadingUnitBuffer","trailingUnitBuffer","add","roundedStart","roundedEnd","delta","i","newTick","restore","getLabelForIndex","tooltipFormat","formattedTick","tickOpts","callback","userCallback","convertTicksToLabels","tickMoments","map","getPixelForValue","offset","decimal","valueOffset","left","heightOffset","top","getPixelForTick","getValueForPixel","pixel","innerDimension","duration","asSeconds","getMonth","console","warn","scaleService","registerScaleType"],"mappings":"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","sourcesContent":["/* global window: false */\n'use strict';\n\nvar moment = require('moment');\nmoment = typeof(moment) === 'function' ? moment : window.moment;\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar time = {\n\t\tunits: [{\n\t\t\tname: 'millisecond',\n\t\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t\t}, {\n\t\t\tname: 'second',\n\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t}, {\n\t\t\tname: 'minute',\n\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t}, {\n\t\t\tname: 'hour',\n\t\t\tsteps: [1, 2, 3, 6, 12]\n\t\t}, {\n\t\t\tname: 'day',\n\t\t\tsteps: [1, 2, 5]\n\t\t}, {\n\t\t\tname: 'week',\n\t\t\tmaxStep: 4\n\t\t}, {\n\t\t\tname: 'month',\n\t\t\tmaxStep: 3\n\t\t}, {\n\t\t\tname: 'quarter',\n\t\t\tmaxStep: 4\n\t\t}, {\n\t\t\tname: 'year',\n\t\t\tmaxStep: false\n\t\t}]\n\t};\n\n\tvar defaultConfig = {\n\t\tposition: 'bottom',\n\n\t\ttime: {\n\t\t\tparser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\tisoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\tminUnit: 'millisecond',\n\n\t\t\t// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n\t\t\tdisplayFormats: {\n\t\t\t\tmillisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n\t\t\t\tsecond: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\tminute: 'h:mm:ss a', // 11:20:01 AM\n\t\t\t\thour: 'MMM D, hA', // Sept 4, 5PM\n\t\t\t\tday: 'll', // Sep 4 2015\n\t\t\t\tweek: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n\t\t\t\tmonth: 'MMM YYYY', // Sept 2015\n\t\t\t\tquarter: '[Q]Q - YYYY', // Q3\n\t\t\t\tyear: 'YYYY' // 2015\n\t\t\t}\n\t\t},\n\t\tticks: {\n\t\t\tautoSkip: false\n\t\t}\n\t};\n\n\tvar TimeScale = Chart.Scale.extend({\n\t\tinitialize: function() {\n\t\t\tif (!moment) {\n\t\t\t\tthrow new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n\t\t\t}\n\n\t\t\tChart.Scale.prototype.initialize.call(this);\n\t\t},\n\t\tgetLabelMoment: function(datasetIndex, index) {\n\t\t\tif (datasetIndex === null || index === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (typeof this.labelMoments[datasetIndex] !== 'undefined') {\n\t\t\t\treturn this.labelMoments[datasetIndex][index];\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\t\tgetLabelDiff: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tif (datasetIndex === null || index === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (me.labelDiffs === undefined) {\n\t\t\t\tme.buildLabelDiffs();\n\t\t\t}\n\n\t\t\tif (typeof me.labelDiffs[datasetIndex] !== 'undefined') {\n\t\t\t\treturn me.labelDiffs[datasetIndex][index];\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\t\tgetMomentStartOf: function(tick) {\n\t\t\tvar me = this;\n\t\t\tif (me.options.time.unit === 'week' && me.options.time.isoWeekday !== false) {\n\t\t\t\treturn tick.clone().startOf('isoWeek').isoWeekday(me.options.time.isoWeekday);\n\t\t\t}\n\t\t\treturn tick.clone().startOf(me.tickUnit);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tme.labelMoments = [];\n\n\t\t\t// Only parse these once. If the dataset does not have data as x,y pairs, we will use\n\t\t\t// these\n\t\t\tvar scaleLabelMoments = [];\n\t\t\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {\n\t\t\t\thelpers.each(me.chart.data.labels, function(label) {\n\t\t\t\t\tvar labelMoment = me.parseTime(label);\n\n\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscaleLabelMoments.push(labelMoment);\n\t\t\t\t\t}\n\t\t\t\t}, me);\n\n\t\t\t\tme.firstTick = moment.min.call(me, scaleLabelMoments);\n\t\t\t\tme.lastTick = moment.max.call(me, scaleLabelMoments);\n\t\t\t} else {\n\t\t\t\tme.firstTick = null;\n\t\t\t\tme.lastTick = null;\n\t\t\t}\n\n\t\t\thelpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar momentsForDataset = [];\n\t\t\t\tvar datasetVisible = me.chart.isDatasetVisible(datasetIndex);\n\n\t\t\t\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\n\t\t\t\t\thelpers.each(dataset.data, function(value) {\n\t\t\t\t\t\tvar labelMoment = me.parseTime(me.getRightValue(value));\n\n\t\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmomentsForDataset.push(labelMoment);\n\n\t\t\t\t\t\t\tif (datasetVisible) {\n\t\t\t\t\t\t\t\t// May have gone outside the scale ranges, make sure we keep the first and last ticks updated\n\t\t\t\t\t\t\t\tme.firstTick = me.firstTick !== null ? moment.min(me.firstTick, labelMoment) : labelMoment;\n\t\t\t\t\t\t\t\tme.lastTick = me.lastTick !== null ? moment.max(me.lastTick, labelMoment) : labelMoment;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, me);\n\t\t\t\t} else {\n\t\t\t\t\t// We have no labels. Use the ones from the scale\n\t\t\t\t\tmomentsForDataset = scaleLabelMoments;\n\t\t\t\t}\n\n\t\t\t\tme.labelMoments.push(momentsForDataset);\n\t\t\t}, me);\n\n\t\t\t// Set these after we've done all the data\n\t\t\tif (me.options.time.min) {\n\t\t\t\tme.firstTick = me.parseTime(me.options.time.min);\n\t\t\t}\n\n\t\t\tif (me.options.time.max) {\n\t\t\t\tme.lastTick = me.parseTime(me.options.time.max);\n\t\t\t}\n\n\t\t\t// We will modify these, so clone for later\n\t\t\tme.firstTick = (me.firstTick || moment()).clone();\n\t\t\tme.lastTick = (me.lastTick || moment()).clone();\n\t\t},\n\t\tbuildLabelDiffs: function() {\n\t\t\tvar me = this;\n\t\t\tme.labelDiffs = [];\n\t\t\tvar scaleLabelDiffs = [];\n\t\t\t// Parse common labels once\n\t\t\tif (me.chart.data.labels && me.chart.data.labels.length > 0) {\n\t\t\t\thelpers.each(me.chart.data.labels, function(label) {\n\t\t\t\t\tvar labelMoment = me.parseTime(label);\n\n\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscaleLabelDiffs.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\n\t\t\t\t\t}\n\t\t\t\t}, me);\n\t\t\t}\n\n\t\t\thelpers.each(me.chart.data.datasets, function(dataset) {\n\t\t\t\tvar diffsForDataset = [];\n\n\t\t\t\tif (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\n\t\t\t\t\thelpers.each(dataset.data, function(value) {\n\t\t\t\t\t\tvar labelMoment = me.parseTime(me.getRightValue(value));\n\n\t\t\t\t\t\tif (labelMoment.isValid()) {\n\t\t\t\t\t\t\tif (me.options.time.round) {\n\t\t\t\t\t\t\t\tlabelMoment.startOf(me.options.time.round);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdiffsForDataset.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\n\t\t\t\t\t\t}\n\t\t\t\t\t}, me);\n\t\t\t\t} else {\n\t\t\t\t\t// We have no labels. Use common ones\n\t\t\t\t\tdiffsForDataset = scaleLabelDiffs;\n\t\t\t\t}\n\n\t\t\t\tme.labelDiffs.push(diffsForDataset);\n\t\t\t}, me);\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\n\t\t\tme.ctx.save();\n\t\t\tvar tickFontSize = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);\n\t\t\tvar tickFontStyle = helpers.getValueOrDefault(me.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);\n\t\t\tvar tickFontFamily = helpers.getValueOrDefault(me.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);\n\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\t\t\tme.ctx.font = tickLabelFont;\n\n\t\t\tme.ticks = [];\n\t\t\tme.unitScale = 1; // How much we scale the unit by, ie 2 means 2x unit per step\n\t\t\tme.scaleSizeInUnits = 0; // How large the scale is in the base unit (seconds, minutes, etc)\n\n\t\t\t// Set unit override if applicable\n\t\t\tif (me.options.time.unit) {\n\t\t\t\tme.tickUnit = me.options.time.unit || 'day';\n\t\t\t\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];\n\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, 1);\n\t\t\t} else {\n\t\t\t\t// Determine the smallest needed unit of the time\n\t\t\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\n\t\t\t\t// Crude approximation of what the label length might be\n\t\t\t\tvar tempFirstLabel = me.tickFormatFunction(me.firstTick, 0, []);\n\t\t\t\tvar tickLabelWidth = me.ctx.measureText(tempFirstLabel).width;\n\t\t\t\tvar cosRotation = Math.cos(helpers.toRadians(me.options.ticks.maxRotation));\n\t\t\t\tvar sinRotation = Math.sin(helpers.toRadians(me.options.ticks.maxRotation));\n\t\t\t\ttickLabelWidth = (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t\t\t\tvar labelCapacity = innerWidth / (tickLabelWidth);\n\n\t\t\t\t// Start as small as possible\n\t\t\t\tme.tickUnit = me.options.time.minUnit;\n\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\tme.displayFormat = me.options.time.displayFormats[me.tickUnit];\n\n\t\t\t\tvar unitDefinitionIndex = 0;\n\t\t\t\tvar unitDefinition = time.units[unitDefinitionIndex];\n\n\t\t\t\t// While we aren't ideal and we don't have units left\n\t\t\t\twhile (unitDefinitionIndex < time.units.length) {\n\t\t\t\t\t// Can we scale this unit. If `false` we can scale infinitely\n\t\t\t\t\tme.unitScale = 1;\n\n\t\t\t\t\tif (helpers.isArray(unitDefinition.steps) && Math.ceil(me.scaleSizeInUnits / labelCapacity) < helpers.max(unitDefinition.steps)) {\n\t\t\t\t\t\t// Use one of the predefined steps\n\t\t\t\t\t\tfor (var idx = 0; idx < unitDefinition.steps.length; ++idx) {\n\t\t\t\t\t\t\tif (unitDefinition.steps[idx] >= Math.ceil(me.scaleSizeInUnits / labelCapacity)) {\n\t\t\t\t\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, unitDefinition.steps[idx]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if ((unitDefinition.maxStep === false) || (Math.ceil(me.scaleSizeInUnits / labelCapacity) < unitDefinition.maxStep)) {\n\t\t\t\t\t\t// We have a max step. Scale this unit\n\t\t\t\t\t\tme.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, Math.ceil(me.scaleSizeInUnits / labelCapacity));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Move to the next unit up\n\t\t\t\t\t\t++unitDefinitionIndex;\n\t\t\t\t\t\tunitDefinition = time.units[unitDefinitionIndex];\n\n\t\t\t\t\t\tme.tickUnit = unitDefinition.name;\n\t\t\t\t\t\tvar leadingUnitBuffer = me.firstTick.diff(me.getMomentStartOf(me.firstTick), me.tickUnit, true);\n\t\t\t\t\t\tvar trailingUnitBuffer = me.getMomentStartOf(me.lastTick.clone().add(1, me.tickUnit)).diff(me.lastTick, me.tickUnit, true);\n\t\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;\n\t\t\t\t\t\tme.displayFormat = me.options.time.displayFormats[unitDefinition.name];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar roundedStart;\n\n\t\t\t// Only round the first tick if we have no hard minimum\n\t\t\tif (!me.options.time.min) {\n\t\t\t\tme.firstTick = me.getMomentStartOf(me.firstTick);\n\t\t\t\troundedStart = me.firstTick;\n\t\t\t} else {\n\t\t\t\troundedStart = me.getMomentStartOf(me.firstTick);\n\t\t\t}\n\n\t\t\t// Only round the last tick if we have no hard maximum\n\t\t\tif (!me.options.time.max) {\n\t\t\t\tvar roundedEnd = me.getMomentStartOf(me.lastTick);\n\t\t\t\tvar delta = roundedEnd.diff(me.lastTick, me.tickUnit, true);\n\t\t\t\tif (delta < 0) {\n\t\t\t\t\t// Do not use end of because we need me to be in the next time unit\n\t\t\t\t\tme.lastTick = me.getMomentStartOf(me.lastTick.add(1, me.tickUnit));\n\t\t\t\t} else if (delta >= 0) {\n\t\t\t\t\tme.lastTick = roundedEnd;\n\t\t\t\t}\n\n\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t}\n\n\t\t\t// Tick displayFormat override\n\t\t\tif (me.options.time.displayFormat) {\n\t\t\t\tme.displayFormat = me.options.time.displayFormat;\n\t\t\t}\n\n\t\t\t// first tick. will have been rounded correctly if options.time.min is not specified\n\t\t\tme.ticks.push(me.firstTick.clone());\n\n\t\t\t// For every unit in between the first and last moment, create a moment and add it to the ticks tick\n\t\t\tfor (var i = me.unitScale; i <= me.scaleSizeInUnits; i += me.unitScale) {\n\t\t\t\tvar newTick = roundedStart.clone().add(i, me.tickUnit);\n\n\t\t\t\t// Are we greater than the max time\n\t\t\t\tif (me.options.time.max && newTick.diff(me.lastTick, me.tickUnit, true) >= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tme.ticks.push(newTick);\n\t\t\t}\n\n\t\t\t// Always show the right tick\n\t\t\tvar diff = me.ticks[me.ticks.length - 1].diff(me.lastTick, me.tickUnit);\n\t\t\tif (diff !== 0 || me.scaleSizeInUnits === 0) {\n\t\t\t\t// this is a weird case. If the <max> option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart\n\t\t\t\t// but the last tick was not rounded.\n\t\t\t\tif (me.options.time.max) {\n\t\t\t\t\tme.ticks.push(me.lastTick.clone());\n\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.ticks[0], me.tickUnit, true);\n\t\t\t\t} else {\n\t\t\t\t\tme.ticks.push(me.lastTick.clone());\n\t\t\t\t\tme.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.ctx.restore();\n\n\t\t\t// Invalidate label diffs cache\n\t\t\tme.labelDiffs = undefined;\n\t\t},\n\t\t// Get tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';\n\t\t\tvar value = me.chart.data.datasets[datasetIndex].data[index];\n\n\t\t\tif (value !== null && typeof value === 'object') {\n\t\t\t\tlabel = me.getRightValue(value);\n\t\t\t}\n\n\t\t\t// Format nicely\n\t\t\tif (me.options.time.tooltipFormat) {\n\t\t\t\tlabel = me.parseTime(label).format(me.options.time.tooltipFormat);\n\t\t\t}\n\n\t\t\treturn label;\n\t\t},\n\t\t// Function to format an individual tick mark\n\t\ttickFormatFunction: function(tick, index, ticks) {\n\t\t\tvar formattedTick = tick.format(this.displayFormat);\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);\n\n\t\t\tif (callback) {\n\t\t\t\treturn callback(formattedTick, index, ticks);\n\t\t\t}\n\t\t\treturn formattedTick;\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.tickMoments = me.ticks;\n\t\t\tme.ticks = me.ticks.map(me.tickFormatFunction, me);\n\t\t},\n\t\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar offset = null;\n\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\toffset = me.getLabelDiff(datasetIndex, index);\n\t\t\t}\n\n\t\t\tif (offset === null) {\n\t\t\t\tif (!value || !value.isValid) {\n\t\t\t\t\t// not already a moment object\n\t\t\t\t\tvalue = me.parseTime(me.getRightValue(value));\n\t\t\t\t}\n\t\t\t\tif (value && value.isValid && value.isValid()) {\n\t\t\t\t\toffset = value.diff(me.firstTick, me.tickUnit, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (offset !== null) {\n\t\t\t\tvar decimal = offset !== 0 ? offset / me.scaleSizeInUnits : offset;\n\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\tvar valueOffset = (me.width * decimal);\n\t\t\t\t\treturn me.left + Math.round(valueOffset);\n\t\t\t\t}\n\n\t\t\t\tvar heightOffset = (me.height * decimal);\n\t\t\t\treturn me.top + Math.round(heightOffset);\n\t\t\t}\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickMoments[index], null, null);\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar innerDimension = me.isHorizontal() ? me.width : me.height;\n\t\t\tvar offset = (pixel - (me.isHorizontal() ? me.left : me.top)) / innerDimension;\n\t\t\toffset *= me.scaleSizeInUnits;\n\t\t\treturn me.firstTick.clone().add(moment.duration(offset, me.tickUnit).asSeconds(), 'seconds');\n\t\t},\n\t\tparseTime: function(label) {\n\t\t\tvar me = this;\n\t\t\tif (typeof me.options.time.parser === 'string') {\n\t\t\t\treturn moment(label, me.options.time.parser);\n\t\t\t}\n\t\t\tif (typeof me.options.time.parser === 'function') {\n\t\t\t\treturn me.options.time.parser(label);\n\t\t\t}\n\t\t\t// Date objects\n\t\t\tif (typeof label.getMonth === 'function' || typeof label === 'number') {\n\t\t\t\treturn moment(label);\n\t\t\t}\n\t\t\t// Moment support\n\t\t\tif (label.isValid && label.isValid()) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t\t// Custom parsing (return an instance of moment)\n\t\t\tif (typeof me.options.time.format !== 'string' && me.options.time.format.call) {\n\t\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale');\n\t\t\t\treturn me.options.time.format(label);\n\t\t\t}\n\t\t\t// Moment format parsing\n\t\t\treturn moment(label, me.options.time.format);\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\n\n};\n"]},"metadata":{},"sourceType":"script"}