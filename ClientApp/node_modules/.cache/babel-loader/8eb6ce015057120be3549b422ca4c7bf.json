{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  var globalDefaults = Chart.defaults.global;\n  var defaultConfig = {\n    display: true,\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    lineArc: false,\n    position: 'chartArea',\n    angleLines: {\n      display: true,\n      color: 'rgba(0, 0, 0, 0.1)',\n      lineWidth: 1\n    },\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n      // String - The colour of the label backdrop\n      backdropColor: 'rgba(255,255,255,0.75)',\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPaddingY: 2,\n      // Number - The backdrop padding to the side of the label in pixels\n      backdropPaddingX: 2,\n      callback: Chart.Ticks.formatters.linear\n    },\n    pointLabels: {\n      // Number - Point label font size in pixels\n      fontSize: 10,\n      // Function - Used to convert point labels\n      callback: function (label) {\n        return label;\n      }\n    }\n  };\n\n  function getValueCount(scale) {\n    return !scale.options.lineArc ? scale.chart.data.labels.length : 0;\n  }\n\n  function getPointLabelFontOptions(scale) {\n    var pointLabelOptions = scale.options.pointLabels;\n    var fontSize = helpers.getValueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n    var fontStyle = helpers.getValueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n    var fontFamily = helpers.getValueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n    var font = helpers.fontString(fontSize, fontStyle, fontFamily);\n    return {\n      size: fontSize,\n      style: fontStyle,\n      family: fontFamily,\n      font: font\n    };\n  }\n\n  function measureLabelSize(ctx, fontSize, label) {\n    if (helpers.isArray(label)) {\n      return {\n        w: helpers.longestText(ctx, ctx.font, label),\n        h: label.length * fontSize + (label.length - 1) * 1.5 * fontSize\n      };\n    }\n\n    return {\n      w: ctx.measureText(label).width,\n      h: fontSize\n    };\n  }\n\n  function determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n      return {\n        start: pos - size / 2,\n        end: pos + size / 2\n      };\n    } else if (angle < min || angle > max) {\n      return {\n        start: pos - size - 5,\n        end: pos\n      };\n    }\n\n    return {\n      start: pos,\n      end: pos + size + 5\n    };\n  }\n  /**\n   * Helper function to fit a radial linear scale with point labels\n   */\n\n\n  function fitWithPointLabels(scale) {\n    /*\n     * Right, this is really confusing and there is a lot of maths going on here\n     * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n     *\n     * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n     *\n     * Solution:\n     *\n     * We assume the radius of the polygon is half the size of the canvas at first\n     * at each index we check if the text overlaps.\n     *\n     * Where it does, we store that angle and that index.\n     *\n     * After finding the largest index and angle we calculate how much we need to remove\n     * from the shape radius to move the point inwards by that x.\n     *\n     * We average the left and right distances to get the maximum shape radius that can fit in the box\n     * along with labels.\n     *\n     * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n     * on each side, removing that from the size, halving it and adding the left x protrusion width.\n     *\n     * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n     * and position it in the most space efficient manner\n     *\n     * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n     */\n    var plFont = getPointLabelFontOptions(scale); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n    // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\n    var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n    var furthestLimits = {\n      l: scale.width,\n      r: 0,\n      t: scale.height,\n      b: 0\n    };\n    var furthestAngles = {};\n    var i;\n    var textSize;\n    var pointPosition;\n    scale.ctx.font = plFont.font;\n    scale._pointLabelSizes = [];\n    var valueCount = getValueCount(scale);\n\n    for (i = 0; i < valueCount; i++) {\n      pointPosition = scale.getPointPosition(i, largestPossibleRadius);\n      textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n      scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle\n\n      var angleRadians = scale.getIndexAngle(i);\n      var angle = helpers.toDegrees(angleRadians) % 360;\n      var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n      var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n      if (hLimits.start < furthestLimits.l) {\n        furthestLimits.l = hLimits.start;\n        furthestAngles.l = angleRadians;\n      }\n\n      if (hLimits.end > furthestLimits.r) {\n        furthestLimits.r = hLimits.end;\n        furthestAngles.r = angleRadians;\n      }\n\n      if (vLimits.start < furthestLimits.t) {\n        furthestLimits.t = vLimits.start;\n        furthestAngles.t = angleRadians;\n      }\n\n      if (vLimits.end > furthestLimits.b) {\n        furthestLimits.b = vLimits.end;\n        furthestAngles.b = angleRadians;\n      }\n    }\n\n    scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n  }\n  /**\n   * Helper function to fit a radial linear scale with no point labels\n   */\n\n\n  function fit(scale) {\n    var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n    scale.drawingArea = Math.round(largestPossibleRadius);\n    scale.setCenterPoint(0, 0, 0, 0);\n  }\n\n  function getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n      return 'center';\n    } else if (angle < 180) {\n      return 'left';\n    }\n\n    return 'right';\n  }\n\n  function fillText(ctx, text, position, fontSize) {\n    if (helpers.isArray(text)) {\n      var y = position.y;\n      var spacing = 1.5 * fontSize;\n\n      for (var i = 0; i < text.length; ++i) {\n        ctx.fillText(text[i], position.x, y);\n        y += spacing;\n      }\n    } else {\n      ctx.fillText(text, position.x, position.y);\n    }\n  }\n\n  function adjustPointPositionForLabelHeight(angle, textSize, position) {\n    if (angle === 90 || angle === 270) {\n      position.y -= textSize.h / 2;\n    } else if (angle > 270 || angle < 90) {\n      position.y -= textSize.h;\n    }\n  }\n\n  function drawPointLabels(scale) {\n    var ctx = scale.ctx;\n    var getValueOrDefault = helpers.getValueOrDefault;\n    var opts = scale.options;\n    var angleLineOpts = opts.angleLines;\n    var pointLabelOpts = opts.pointLabels;\n    ctx.lineWidth = angleLineOpts.lineWidth;\n    ctx.strokeStyle = angleLineOpts.color;\n    var outerDistance = scale.getDistanceFromCenterForValue(opts.reverse ? scale.min : scale.max); // Point Label Font\n\n    var plFont = getPointLabelFontOptions(scale);\n    ctx.textBaseline = 'top';\n\n    for (var i = getValueCount(scale) - 1; i >= 0; i--) {\n      if (angleLineOpts.display) {\n        var outerPosition = scale.getPointPosition(i, outerDistance);\n        ctx.beginPath();\n        ctx.moveTo(scale.xCenter, scale.yCenter);\n        ctx.lineTo(outerPosition.x, outerPosition.y);\n        ctx.stroke();\n        ctx.closePath();\n      } // Extra 3px out for some label spacing\n\n\n      var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5); // Keep this in loop since we may support array properties here\n\n      var pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);\n      ctx.font = plFont.font;\n      ctx.fillStyle = pointLabelFontColor;\n      var angleRadians = scale.getIndexAngle(i);\n      var angle = helpers.toDegrees(angleRadians);\n      ctx.textAlign = getTextAlignForAngle(angle);\n      adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n      fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n    }\n  }\n\n  function drawRadiusLine(scale, gridLineOpts, radius, index) {\n    var ctx = scale.ctx;\n    ctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);\n    ctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\n    if (scale.options.lineArc) {\n      // Draw circular arcs between the points\n      ctx.beginPath();\n      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n      ctx.closePath();\n      ctx.stroke();\n    } else {\n      // Draw straight lines connecting each index\n      var valueCount = getValueCount(scale);\n\n      if (valueCount === 0) {\n        return;\n      }\n\n      ctx.beginPath();\n      var pointPosition = scale.getPointPosition(0, radius);\n      ctx.moveTo(pointPosition.x, pointPosition.y);\n\n      for (var i = 1; i < valueCount; i++) {\n        pointPosition = scale.getPointPosition(i, radius);\n        ctx.lineTo(pointPosition.x, pointPosition.y);\n      }\n\n      ctx.closePath();\n      ctx.stroke();\n    }\n  }\n\n  function numberOrZero(param) {\n    return helpers.isNumber(param) ? param : 0;\n  }\n\n  var LinearRadialScale = Chart.LinearScaleBase.extend({\n    setDimensions: function () {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // Set the unconstrained dimension before label rotation\n\n      me.width = me.maxWidth;\n      me.height = me.maxHeight;\n      me.xCenter = Math.round(me.width / 2);\n      me.yCenter = Math.round(me.height / 2);\n      var minSize = helpers.min([me.height, me.width]);\n      var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n      me.drawingArea = opts.display ? minSize / 2 - (tickFontSize / 2 + tickOpts.backdropPaddingY) : minSize / 2;\n    },\n    determineDataLimits: function () {\n      var me = this;\n      var chart = me.chart;\n      var min = Number.POSITIVE_INFINITY;\n      var max = Number.NEGATIVE_INFINITY;\n      helpers.each(chart.data.datasets, function (dataset, datasetIndex) {\n        if (chart.isDatasetVisible(datasetIndex)) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n          helpers.each(dataset.data, function (rawValue, index) {\n            var value = +me.getRightValue(rawValue);\n\n            if (isNaN(value) || meta.data[index].hidden) {\n              return;\n            }\n\n            min = Math.min(value, min);\n            max = Math.max(value, max);\n          });\n        }\n      });\n      me.min = min === Number.POSITIVE_INFINITY ? 0 : min;\n      me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\n      me.handleTickRangeOptions();\n    },\n    getTickLimit: function () {\n      var tickOpts = this.options.ticks;\n      var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n      return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n    },\n    convertTicksToLabels: function () {\n      var me = this;\n      Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me); // Point labels\n\n      me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n    },\n    getLabelForIndex: function (index, datasetIndex) {\n      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    fit: function () {\n      if (this.options.lineArc) {\n        fit(this);\n      } else {\n        fitWithPointLabels(this);\n      }\n    },\n\n    /**\n     * Set radius reductions and determine new radius and center point\n     * @private\n     */\n    setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {\n      var me = this;\n      var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n      var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n      var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n      var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n      radiusReductionLeft = numberOrZero(radiusReductionLeft);\n      radiusReductionRight = numberOrZero(radiusReductionRight);\n      radiusReductionTop = numberOrZero(radiusReductionTop);\n      radiusReductionBottom = numberOrZero(radiusReductionBottom);\n      me.drawingArea = Math.min(Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n      me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n    },\n    setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {\n      var me = this;\n      var maxRight = me.width - rightMovement - me.drawingArea,\n          maxLeft = leftMovement + me.drawingArea,\n          maxTop = topMovement + me.drawingArea,\n          maxBottom = me.height - bottomMovement - me.drawingArea;\n      me.xCenter = Math.round((maxLeft + maxRight) / 2 + me.left);\n      me.yCenter = Math.round((maxTop + maxBottom) / 2 + me.top);\n    },\n    getIndexAngle: function (index) {\n      var angleMultiplier = Math.PI * 2 / getValueCount(this);\n      var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;\n      var startAngleRadians = startAngle * Math.PI * 2 / 360; // Start from the top instead of right, so remove a quarter of the circle\n\n      return index * angleMultiplier + startAngleRadians;\n    },\n    getDistanceFromCenterForValue: function (value) {\n      var me = this;\n\n      if (value === null) {\n        return 0; // null always in center\n      } // Take into account half font size + the yPadding of the top value\n\n\n      var scalingFactor = me.drawingArea / (me.max - me.min);\n\n      if (me.options.reverse) {\n        return (me.max - value) * scalingFactor;\n      }\n\n      return (value - me.min) * scalingFactor;\n    },\n    getPointPosition: function (index, distanceFromCenter) {\n      var me = this;\n      var thisAngle = me.getIndexAngle(index) - Math.PI / 2;\n      return {\n        x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n        y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n      };\n    },\n    getPointPositionForValue: function (index, value) {\n      return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    },\n    getBasePosition: function () {\n      var me = this;\n      var min = me.min;\n      var max = me.max;\n      return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);\n    },\n    draw: function () {\n      var me = this;\n      var opts = me.options;\n      var gridLineOpts = opts.gridLines;\n      var tickOpts = opts.ticks;\n      var getValueOrDefault = helpers.getValueOrDefault;\n\n      if (opts.display) {\n        var ctx = me.ctx; // Tick Font\n\n        var tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n        var tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n        var tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n        var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n        helpers.each(me.ticks, function (label, index) {\n          // Don't draw a centre value (if it is minimum)\n          if (index > 0 || opts.reverse) {\n            var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n            var yHeight = me.yCenter - yCenterOffset; // Draw circular lines around the scale\n\n            if (gridLineOpts.display && index !== 0) {\n              drawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n            }\n\n            if (tickOpts.display) {\n              var tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n              ctx.font = tickLabelFont;\n\n              if (tickOpts.showLabelBackdrop) {\n                var labelWidth = ctx.measureText(label).width;\n                ctx.fillStyle = tickOpts.backdropColor;\n                ctx.fillRect(me.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX, yHeight - tickFontSize / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFontSize + tickOpts.backdropPaddingY * 2);\n              }\n\n              ctx.textAlign = 'center';\n              ctx.textBaseline = 'middle';\n              ctx.fillStyle = tickFontColor;\n              ctx.fillText(label, me.xCenter, yHeight);\n            }\n          }\n        });\n\n        if (!opts.lineArc) {\n          drawPointLabels(me);\n        }\n      }\n    }\n  });\n  Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/scales/scale.radialLinear.js"],"names":["module","exports","Chart","helpers","globalDefaults","defaults","global","defaultConfig","display","animate","lineArc","position","angleLines","color","lineWidth","ticks","showLabelBackdrop","backdropColor","backdropPaddingY","backdropPaddingX","callback","Ticks","formatters","linear","pointLabels","fontSize","label","getValueCount","scale","options","chart","data","labels","length","getPointLabelFontOptions","pointLabelOptions","getValueOrDefault","defaultFontSize","fontStyle","defaultFontStyle","fontFamily","defaultFontFamily","font","fontString","size","style","family","measureLabelSize","ctx","isArray","w","longestText","h","measureText","width","determineLimits","angle","pos","min","max","start","end","fitWithPointLabels","plFont","largestPossibleRadius","Math","height","furthestLimits","l","r","t","b","furthestAngles","i","textSize","pointPosition","_pointLabelSizes","valueCount","getPointPosition","angleRadians","getIndexAngle","toDegrees","hLimits","x","vLimits","y","setReductions","fit","drawingArea","round","setCenterPoint","getTextAlignForAngle","fillText","text","spacing","adjustPointPositionForLabelHeight","drawPointLabels","opts","angleLineOpts","pointLabelOpts","strokeStyle","outerDistance","getDistanceFromCenterForValue","reverse","textBaseline","outerPosition","beginPath","moveTo","xCenter","yCenter","lineTo","stroke","closePath","pointLabelPosition","pointLabelFontColor","fontColor","defaultFontColor","fillStyle","textAlign","drawRadiusLine","gridLineOpts","radius","index","getValueAtIndexOrDefault","arc","PI","numberOrZero","param","isNumber","LinearRadialScale","LinearScaleBase","extend","setDimensions","me","tickOpts","maxWidth","maxHeight","minSize","tickFontSize","determineDataLimits","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","each","datasets","dataset","datasetIndex","isDatasetVisible","meta","getDatasetMeta","rawValue","value","getRightValue","isNaN","hidden","handleTickRangeOptions","getTickLimit","maxTicksLimit","ceil","convertTicksToLabels","prototype","call","map","getLabelForIndex","radiusReductionLeft","sin","radiusReductionRight","radiusReductionTop","cos","radiusReductionBottom","leftMovement","rightMovement","topMovement","bottomMovement","maxRight","maxLeft","maxTop","maxBottom","left","top","angleMultiplier","startAngle","startAngleRadians","scalingFactor","distanceFromCenter","thisAngle","getPointPositionForValue","getBasePosition","beginAtZero","draw","gridLines","tickFontStyle","tickFontFamily","tickLabelFont","yCenterOffset","ticksAsNumbers","yHeight","tickFontColor","labelWidth","fillRect","scaleService","registerScaleType"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\tvar globalDefaults = Chart.defaults.global;\n\n\tvar defaultConfig = {\n\t\tdisplay: true,\n\n\t\t// Boolean - Whether to animate scaling the chart from the centre\n\t\tanimate: true,\n\t\tlineArc: false,\n\t\tposition: 'chartArea',\n\n\t\tangleLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\t// Boolean - Show a backdrop to the scale label\n\t\t\tshowLabelBackdrop: true,\n\n\t\t\t// String - The colour of the label backdrop\n\t\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\n\t\t\t// Number - The backdrop padding above & below the label in pixels\n\t\t\tbackdropPaddingY: 2,\n\n\t\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\t\tbackdropPaddingX: 2,\n\n\t\t\tcallback: Chart.Ticks.formatters.linear\n\t\t},\n\n\t\tpointLabels: {\n\t\t\t// Number - Point label font size in pixels\n\t\t\tfontSize: 10,\n\n\t\t\t// Function - Used to convert point labels\n\t\t\tcallback: function(label) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction getValueCount(scale) {\n\t\treturn !scale.options.lineArc ? scale.chart.data.labels.length : 0;\n\t}\n\n\tfunction getPointLabelFontOptions(scale) {\n\t\tvar pointLabelOptions = scale.options.pointLabels;\n\t\tvar fontSize = helpers.getValueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n\t\tvar fontStyle = helpers.getValueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar fontFamily = helpers.getValueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n\t\tvar font = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\treturn {\n\t\t\tsize: fontSize,\n\t\t\tstyle: fontStyle,\n\t\t\tfamily: fontFamily,\n\t\t\tfont: font\n\t\t};\n\t}\n\n\tfunction measureLabelSize(ctx, fontSize, label) {\n\t\tif (helpers.isArray(label)) {\n\t\t\treturn {\n\t\t\t\tw: helpers.longestText(ctx, ctx.font, label),\n\t\t\t\th: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tw: ctx.measureText(label).width,\n\t\t\th: fontSize\n\t\t};\n\t}\n\n\tfunction determineLimits(angle, pos, size, min, max) {\n\t\tif (angle === min || angle === max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - (size / 2),\n\t\t\t\tend: pos + (size / 2)\n\t\t\t};\n\t\t} else if (angle < min || angle > max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - size - 5,\n\t\t\t\tend: pos\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tstart: pos,\n\t\t\tend: pos + size + 5\n\t\t};\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with point labels\n\t */\n\tfunction fitWithPointLabels(scale) {\n\t\t/*\n\t\t * Right, this is really confusing and there is a lot of maths going on here\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n\t\t *\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n\t\t *\n\t\t * Solution:\n\t\t *\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\n\t\t * at each index we check if the text overlaps.\n\t\t *\n\t\t * Where it does, we store that angle and that index.\n\t\t *\n\t\t * After finding the largest index and angle we calculate how much we need to remove\n\t\t * from the shape radius to move the point inwards by that x.\n\t\t *\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\n\t\t * along with labels.\n\t\t *\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\n\t\t *\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n\t\t * and position it in the most space efficient manner\n\t\t *\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\t\t */\n\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tvar furthestLimits = {\n\t\t\tl: scale.width,\n\t\t\tr: 0,\n\t\t\tt: scale.height,\n\t\t\tb: 0\n\t\t};\n\t\tvar furthestAngles = {};\n\t\tvar i;\n\t\tvar textSize;\n\t\tvar pointPosition;\n\n\t\tscale.ctx.font = plFont.font;\n\t\tscale._pointLabelSizes = [];\n\n\t\tvar valueCount = getValueCount(scale);\n\t\tfor (i = 0; i < valueCount; i++) {\n\t\t\tpointPosition = scale.getPointPosition(i, largestPossibleRadius);\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n\t\t\tscale._pointLabelSizes[i] = textSize;\n\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n\t\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\t\tfurthestAngles.l = angleRadians;\n\t\t\t}\n\n\t\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\t\tfurthestAngles.r = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\t\tfurthestAngles.t = angleRadians;\n\t\t\t}\n\n\t\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\t\tfurthestAngles.b = angleRadians;\n\t\t\t}\n\t\t}\n\n\t\tscale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n\t}\n\n\t/**\n\t * Helper function to fit a radial linear scale with no point labels\n\t */\n\tfunction fit(scale) {\n\t\tvar largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n\t\tscale.drawingArea = Math.round(largestPossibleRadius);\n\t\tscale.setCenterPoint(0, 0, 0, 0);\n\t}\n\n\tfunction getTextAlignForAngle(angle) {\n\t\tif (angle === 0 || angle === 180) {\n\t\t\treturn 'center';\n\t\t} else if (angle < 180) {\n\t\t\treturn 'left';\n\t\t}\n\n\t\treturn 'right';\n\t}\n\n\tfunction fillText(ctx, text, position, fontSize) {\n\t\tif (helpers.isArray(text)) {\n\t\t\tvar y = position.y;\n\t\t\tvar spacing = 1.5 * fontSize;\n\n\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\t\ty+= spacing;\n\t\t\t}\n\t\t} else {\n\t\t\tctx.fillText(text, position.x, position.y);\n\t\t}\n\t}\n\n\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\t\tif (angle === 90 || angle === 270) {\n\t\t\tposition.y -= (textSize.h / 2);\n\t\t} else if (angle > 270 || angle < 90) {\n\t\t\tposition.y -= textSize.h;\n\t\t}\n\t}\n\n\tfunction drawPointLabels(scale) {\n\t\tvar ctx = scale.ctx;\n\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\tvar opts = scale.options;\n\t\tvar angleLineOpts = opts.angleLines;\n\t\tvar pointLabelOpts = opts.pointLabels;\n\n\t\tctx.lineWidth = angleLineOpts.lineWidth;\n\t\tctx.strokeStyle = angleLineOpts.color;\n\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.reverse ? scale.min : scale.max);\n\n\t\t// Point Label Font\n\t\tvar plFont = getPointLabelFontOptions(scale);\n\n\t\tctx.textBaseline = 'top';\n\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\n\t\t\tif (angleLineOpts.display) {\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.closePath();\n\t\t\t}\n\t\t\t// Extra 3px out for some label spacing\n\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\n\n\t\t\t// Keep this in loop since we may support array properties here\n\t\t\tvar pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\tctx.font = plFont.font;\n\t\t\tctx.fillStyle = pointLabelFontColor;\n\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers.toDegrees(angleRadians);\n\t\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n\t\t}\n\t}\n\n\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\t\tvar ctx = scale.ctx;\n\t\tctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);\n\t\tctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n\n\t\tif (scale.options.lineArc) {\n\t\t\t// Draw circular arcs between the points\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t} else {\n\t\t\t// Draw straight lines connecting each index\n\t\t\tvar valueCount = getValueCount(scale);\n\n\t\t\tif (valueCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tctx.beginPath();\n\t\t\tvar pointPosition = scale.getPointPosition(0, radius);\n\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\n\t\t\tfor (var i = 1; i < valueCount; i++) {\n\t\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t\t}\n\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t}\n\t}\n\n\tfunction numberOrZero(param) {\n\t\treturn helpers.isNumber(param) ? param : 0;\n\t}\n\n\tvar LinearRadialScale = Chart.LinearScaleBase.extend({\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.xCenter = Math.round(me.width / 2);\n\t\t\tme.yCenter = Math.round(me.height / 2);\n\n\t\t\tvar minSize = helpers.min([me.height, me.width]);\n\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\tme.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\n\t\t},\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar min = Number.POSITIVE_INFINITY;\n\t\t\tvar max = Number.NEGATIVE_INFINITY;\n\n\t\t\thelpers.each(chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\n\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmin = Math.min(value, min);\n\t\t\t\t\t\tmax = Math.max(value, max);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\n\t\t\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\n\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tme.handleTickRangeOptions();\n\t\t},\n\t\tgetTickLimit: function() {\n\t\t\tvar tickOpts = this.options.ticks;\n\t\t\tvar tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tChart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\n\n\t\t\t// Point labels\n\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t\t},\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tfit: function() {\n\t\t\tif (this.options.lineArc) {\n\t\t\t\tfit(this);\n\t\t\t} else {\n\t\t\t\tfitWithPointLabels(this);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Set radius reductions and determine new radius and center point\n\t\t * @private\n\t\t */\n\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\t\tvar me = this;\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\n\t\t\tme.drawingArea = Math.min(\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n\t\t\t\tMath.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t\t},\n\t\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\t\tvar me = this;\n\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea,\n\t\t\t\tmaxLeft = leftMovement + me.drawingArea,\n\t\t\t\tmaxTop = topMovement + me.drawingArea,\n\t\t\t\tmaxBottom = me.height - bottomMovement - me.drawingArea;\n\n\t\t\tme.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\n\t\t\tme.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);\n\t\t},\n\n\t\tgetIndexAngle: function(index) {\n\t\t\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\n\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\n\t\t\t\tthis.chart.options.startAngle :\n\t\t\t\t0;\n\n\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\n\t\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\t\treturn index * angleMultiplier + startAngleRadians;\n\t\t},\n\t\tgetDistanceFromCenterForValue: function(value) {\n\t\t\tvar me = this;\n\n\t\t\tif (value === null) {\n\t\t\t\treturn 0; // null always in center\n\t\t\t}\n\n\t\t\t// Take into account half font size + the yPadding of the top value\n\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\t\tif (me.options.reverse) {\n\t\t\t\treturn (me.max - value) * scalingFactor;\n\t\t\t}\n\t\t\treturn (value - me.min) * scalingFactor;\n\t\t},\n\t\tgetPointPosition: function(index, distanceFromCenter) {\n\t\t\tvar me = this;\n\t\t\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\n\t\t\treturn {\n\t\t\t\tx: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n\t\t\t\ty: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n\t\t\t};\n\t\t},\n\t\tgetPointPositionForValue: function(index, value) {\n\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t},\n\n\t\tgetBasePosition: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.getPointPositionForValue(0,\n\t\t\t\tme.beginAtZero? 0:\n\t\t\t\tmin < 0 && max < 0? max :\n\t\t\t\tmin > 0 && max > 0? min :\n\t\t\t\t0);\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx;\n\n\t\t\t\t// Tick Font\n\t\t\t\tvar tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n\t\t\t\tvar tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n\t\t\t\tvar tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n\t\t\t\tvar tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n\n\t\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\t\tif (index > 0 || opts.reverse) {\n\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\t\t\t\t\t\tvar yHeight = me.yCenter - yCenterOffset;\n\n\t\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\t\tvar tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\t\t\t\tctx.font = tickLabelFont;\n\n\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\tme.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t\t\t\t\tyHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\t\t\t\t\ttickFontSize + tickOpts.backdropPaddingY * 2\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\t\tctx.fillText(label, me.xCenter, yHeight);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (!opts.lineArc) {\n\t\t\t\t\tdrawPointLabels(me);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n\n};\n"]},"metadata":{},"sourceType":"script"}