{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  Chart.defaults.scale = {\n    display: true,\n    position: 'left',\n    // grid line settings\n    gridLines: {\n      display: true,\n      color: 'rgba(0, 0, 0, 0.1)',\n      lineWidth: 1,\n      drawBorder: true,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickMarkLength: 10,\n      zeroLineWidth: 1,\n      zeroLineColor: 'rgba(0,0,0,0.25)',\n      offsetGridLines: false,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n    // scale label\n    scaleLabel: {\n      // actual label\n      labelString: '',\n      // display property\n      display: false\n    },\n    // label settings\n    ticks: {\n      beginAtZero: false,\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      padding: 0,\n      reverse: false,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 0,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: Chart.Ticks.formatters.values\n    }\n  };\n\n  function computeTextSize(context, tick, font) {\n    return helpers.isArray(tick) ? helpers.longestText(context, font, tick) : context.measureText(tick).width;\n  }\n\n  function parseFontOptions(options) {\n    var getValueOrDefault = helpers.getValueOrDefault;\n    var globalDefaults = Chart.defaults.global;\n    var size = getValueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n    var style = getValueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n    var family = getValueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n    return {\n      size: size,\n      style: style,\n      family: family,\n      font: helpers.fontString(size, style, family)\n    };\n  }\n\n  Chart.Scale = Chart.Element.extend({\n    /**\n     * Get the padding needed for the scale\n     * @method getPadding\n     * @private\n     * @returns {Padding} the necessary padding\n     */\n    getPadding: function () {\n      var me = this;\n      return {\n        left: me.paddingLeft || 0,\n        top: me.paddingTop || 0,\n        right: me.paddingRight || 0,\n        bottom: me.paddingBottom || 0\n      };\n    },\n    // These methods are ordered by lifecyle. Utilities then follow.\n    // Any function defined here is inherited by all scale types.\n    // Any function can be extended by the scale type\n    beforeUpdate: function () {\n      helpers.callCallback(this.options.beforeUpdate, [this]);\n    },\n    update: function (maxWidth, maxHeight, margins) {\n      var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n      me.beforeUpdate(); // Absorb the master measurements\n\n      me.maxWidth = maxWidth;\n      me.maxHeight = maxHeight;\n      me.margins = helpers.extend({\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }, margins);\n      me.longestTextCache = me.longestTextCache || {}; // Dimensions\n\n      me.beforeSetDimensions();\n      me.setDimensions();\n      me.afterSetDimensions(); // Data min/max\n\n      me.beforeDataLimits();\n      me.determineDataLimits();\n      me.afterDataLimits(); // Ticks\n\n      me.beforeBuildTicks();\n      me.buildTicks();\n      me.afterBuildTicks();\n      me.beforeTickToLabelConversion();\n      me.convertTicksToLabels();\n      me.afterTickToLabelConversion(); // Tick Rotation\n\n      me.beforeCalculateTickRotation();\n      me.calculateTickRotation();\n      me.afterCalculateTickRotation(); // Fit\n\n      me.beforeFit();\n      me.fit();\n      me.afterFit(); //\n\n      me.afterUpdate();\n      return me.minSize;\n    },\n    afterUpdate: function () {\n      helpers.callCallback(this.options.afterUpdate, [this]);\n    },\n    //\n    beforeSetDimensions: function () {\n      helpers.callCallback(this.options.beforeSetDimensions, [this]);\n    },\n    setDimensions: function () {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      if (me.isHorizontal()) {\n        // Reset position before calculating rotation\n        me.width = me.maxWidth;\n        me.left = 0;\n        me.right = me.width;\n      } else {\n        me.height = me.maxHeight; // Reset position before calculating rotation\n\n        me.top = 0;\n        me.bottom = me.height;\n      } // Reset padding\n\n\n      me.paddingLeft = 0;\n      me.paddingTop = 0;\n      me.paddingRight = 0;\n      me.paddingBottom = 0;\n    },\n    afterSetDimensions: function () {\n      helpers.callCallback(this.options.afterSetDimensions, [this]);\n    },\n    // Data limits\n    beforeDataLimits: function () {\n      helpers.callCallback(this.options.beforeDataLimits, [this]);\n    },\n    determineDataLimits: helpers.noop,\n    afterDataLimits: function () {\n      helpers.callCallback(this.options.afterDataLimits, [this]);\n    },\n    //\n    beforeBuildTicks: function () {\n      helpers.callCallback(this.options.beforeBuildTicks, [this]);\n    },\n    buildTicks: helpers.noop,\n    afterBuildTicks: function () {\n      helpers.callCallback(this.options.afterBuildTicks, [this]);\n    },\n    beforeTickToLabelConversion: function () {\n      helpers.callCallback(this.options.beforeTickToLabelConversion, [this]);\n    },\n    convertTicksToLabels: function () {\n      var me = this; // Convert ticks to strings\n\n      var tickOpts = me.options.ticks;\n      me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);\n    },\n    afterTickToLabelConversion: function () {\n      helpers.callCallback(this.options.afterTickToLabelConversion, [this]);\n    },\n    //\n    beforeCalculateTickRotation: function () {\n      helpers.callCallback(this.options.beforeCalculateTickRotation, [this]);\n    },\n    calculateTickRotation: function () {\n      var me = this;\n      var context = me.ctx;\n      var tickOpts = me.options.ticks; // Get the width of each grid by calculating the difference\n      // between x offsets between 0 and 1.\n\n      var tickFont = parseFontOptions(tickOpts);\n      context.font = tickFont.font;\n      var labelRotation = tickOpts.minRotation || 0;\n\n      if (me.options.display && me.isHorizontal()) {\n        var originalLabelWidth = helpers.longestText(context, tickFont.font, me.ticks, me.longestTextCache);\n        var labelWidth = originalLabelWidth;\n        var cosRotation;\n        var sinRotation; // Allow 3 pixels x2 padding either side for label readability\n\n        var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6; // Max label rotation can be set or default to 90 - also act as a loop counter\n\n        while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n          var angleRadians = helpers.toRadians(labelRotation);\n          cosRotation = Math.cos(angleRadians);\n          sinRotation = Math.sin(angleRadians);\n\n          if (sinRotation * originalLabelWidth > me.maxHeight) {\n            // go back one step\n            labelRotation--;\n            break;\n          }\n\n          labelRotation++;\n          labelWidth = cosRotation * originalLabelWidth;\n        }\n      }\n\n      me.labelRotation = labelRotation;\n    },\n    afterCalculateTickRotation: function () {\n      helpers.callCallback(this.options.afterCalculateTickRotation, [this]);\n    },\n    //\n    beforeFit: function () {\n      helpers.callCallback(this.options.beforeFit, [this]);\n    },\n    fit: function () {\n      var me = this; // Reset\n\n      var minSize = me.minSize = {\n        width: 0,\n        height: 0\n      };\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var scaleLabelOpts = opts.scaleLabel;\n      var gridLineOpts = opts.gridLines;\n      var display = opts.display;\n      var isHorizontal = me.isHorizontal();\n      var tickFont = parseFontOptions(tickOpts);\n      var scaleLabelFontSize = parseFontOptions(scaleLabelOpts).size * 1.5;\n      var tickMarkLength = opts.gridLines.tickMarkLength; // Width\n\n      if (isHorizontal) {\n        // subtract the margins to line up with the chartArea if we are a full width scale\n        minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n      } else {\n        minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n      } // height\n\n\n      if (isHorizontal) {\n        minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n      } else {\n        minSize.height = me.maxHeight; // fill all the height\n      } // Are we showing a title for the scale?\n\n\n      if (scaleLabelOpts.display && display) {\n        if (isHorizontal) {\n          minSize.height += scaleLabelFontSize;\n        } else {\n          minSize.width += scaleLabelFontSize;\n        }\n      } // Don't bother fitting the ticks if we are not showing them\n\n\n      if (tickOpts.display && display) {\n        var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, me.ticks, me.longestTextCache);\n        var tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);\n        var lineSpace = tickFont.size * 0.5;\n\n        if (isHorizontal) {\n          // A horizontal axis is more constrained by the height.\n          me.longestLabelWidth = largestTextWidth;\n          var angleRadians = helpers.toRadians(me.labelRotation);\n          var cosRotation = Math.cos(angleRadians);\n          var sinRotation = Math.sin(angleRadians); // TODO - improve this calculation\n\n          var labelHeight = sinRotation * largestTextWidth + tickFont.size * tallestLabelHeightInLines + lineSpace * tallestLabelHeightInLines;\n          minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);\n          me.ctx.font = tickFont.font;\n          var firstTick = me.ticks[0];\n          var firstLabelWidth = computeTextSize(me.ctx, firstTick, tickFont.font);\n          var lastTick = me.ticks[me.ticks.length - 1];\n          var lastLabelWidth = computeTextSize(me.ctx, lastTick, tickFont.font); // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated\n          // by the font height\n\n          if (me.labelRotation !== 0) {\n            me.paddingLeft = opts.position === 'bottom' ? cosRotation * firstLabelWidth + 3 : cosRotation * lineSpace + 3; // add 3 px to move away from canvas edges\n\n            me.paddingRight = opts.position === 'bottom' ? cosRotation * lineSpace + 3 : cosRotation * lastLabelWidth + 3;\n          } else {\n            me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\n            me.paddingRight = lastLabelWidth / 2 + 3;\n          }\n        } else {\n          // A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first\n          // Account for padding\n          if (tickOpts.mirror) {\n            largestTextWidth = 0;\n          } else {\n            largestTextWidth += me.options.ticks.padding;\n          }\n\n          minSize.width += largestTextWidth;\n          me.paddingTop = tickFont.size / 2;\n          me.paddingBottom = tickFont.size / 2;\n        }\n      }\n\n      me.handleMargins();\n      me.width = minSize.width;\n      me.height = minSize.height;\n    },\n\n    /**\n     * Handle margins and padding interactions\n     * @private\n     */\n    handleMargins: function () {\n      var me = this;\n\n      if (me.margins) {\n        me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n        me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n        me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n        me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n      }\n    },\n    afterFit: function () {\n      helpers.callCallback(this.options.afterFit, [this]);\n    },\n    // Shared Methods\n    isHorizontal: function () {\n      return this.options.position === 'top' || this.options.position === 'bottom';\n    },\n    isFullWidth: function () {\n      return this.options.fullWidth;\n    },\n    // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n    getRightValue: function (rawValue) {\n      // Null and undefined values first\n      if (rawValue === null || typeof rawValue === 'undefined') {\n        return NaN;\n      } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\n\n      if (typeof rawValue === 'number' && !isFinite(rawValue)) {\n        return NaN;\n      } // If it is in fact an object, dive in one more level\n\n\n      if (typeof rawValue === 'object') {\n        if (rawValue instanceof Date || rawValue.isValid) {\n          return rawValue;\n        }\n\n        return this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);\n      } // Value is good, return it\n\n\n      return rawValue;\n    },\n    // Used to get the value to display in the tooltip for the data at the given index\n    // function getLabelForIndex(index, datasetIndex)\n    getLabelForIndex: helpers.noop,\n    // Used to get data value locations.  Value can either be an index or a numerical value\n    getPixelForValue: helpers.noop,\n    // Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n    getValueForPixel: helpers.noop,\n    // Used for tick location, should\n    getPixelForTick: function (index, includeOffset) {\n      var me = this;\n\n      if (me.isHorizontal()) {\n        var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n        var tickWidth = innerWidth / Math.max(me.ticks.length - (me.options.gridLines.offsetGridLines ? 0 : 1), 1);\n        var pixel = tickWidth * index + me.paddingLeft;\n\n        if (includeOffset) {\n          pixel += tickWidth / 2;\n        }\n\n        var finalVal = me.left + Math.round(pixel);\n        finalVal += me.isFullWidth() ? me.margins.left : 0;\n        return finalVal;\n      }\n\n      var innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n      return me.top + index * (innerHeight / (me.ticks.length - 1));\n    },\n    // Utility for getting the pixel location of a percentage of scale\n    getPixelForDecimal: function (decimal\n    /* , includeOffset*/\n    ) {\n      var me = this;\n\n      if (me.isHorizontal()) {\n        var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n        var valueOffset = innerWidth * decimal + me.paddingLeft;\n        var finalVal = me.left + Math.round(valueOffset);\n        finalVal += me.isFullWidth() ? me.margins.left : 0;\n        return finalVal;\n      }\n\n      return me.top + decimal * me.height;\n    },\n    getBasePixel: function () {\n      return this.getPixelForValue(this.getBaseValue());\n    },\n    getBaseValue: function () {\n      var me = this;\n      var min = me.min;\n      var max = me.max;\n      return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    },\n    // Actually draw the scale on the canvas\n    // @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n    draw: function (chartArea) {\n      var me = this;\n      var options = me.options;\n\n      if (!options.display) {\n        return;\n      }\n\n      var context = me.ctx;\n      var globalDefaults = Chart.defaults.global;\n      var optionTicks = options.ticks;\n      var gridLines = options.gridLines;\n      var scaleLabel = options.scaleLabel;\n      var isRotated = me.labelRotation !== 0;\n      var skipRatio;\n      var useAutoskipper = optionTicks.autoSkip;\n      var isHorizontal = me.isHorizontal(); // figure out the maximum number of gridlines to show\n\n      var maxTicks;\n\n      if (optionTicks.maxTicksLimit) {\n        maxTicks = optionTicks.maxTicksLimit;\n      }\n\n      var tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n      var tickFont = parseFontOptions(optionTicks);\n      var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n      var borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n      var borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n      var scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n      var scaleLabelFont = parseFontOptions(scaleLabel);\n      var labelRotationRadians = helpers.toRadians(me.labelRotation);\n      var cosRotation = Math.cos(labelRotationRadians);\n      var longestRotatedLabel = me.longestLabelWidth * cosRotation; // Make sure we draw text in the correct color and font\n\n      context.fillStyle = tickFontColor;\n      var itemsToDraw = [];\n\n      if (isHorizontal) {\n        skipRatio = false; // Only calculate the skip ratio with the half width of longestRotateLabel if we got an actual rotation\n        // See #2584\n\n        if (isRotated) {\n          longestRotatedLabel /= 2;\n        }\n\n        if ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > me.width - (me.paddingLeft + me.paddingRight)) {\n          skipRatio = 1 + Math.floor((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length / (me.width - (me.paddingLeft + me.paddingRight)));\n        } // if they defined a max number of optionTicks,\n        // increase skipRatio until that number is met\n\n\n        if (maxTicks && me.ticks.length > maxTicks) {\n          while (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {\n            if (!skipRatio) {\n              skipRatio = 1;\n            }\n\n            skipRatio += 1;\n          }\n        }\n\n        if (!useAutoskipper) {\n          skipRatio = false;\n        }\n      }\n\n      var xTickStart = options.position === 'right' ? me.left : me.right - tl;\n      var xTickEnd = options.position === 'right' ? me.left + tl : me.right;\n      var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;\n      var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;\n      helpers.each(me.ticks, function (label, index) {\n        // If the callback returned a null or undefined value, do not draw this line\n        if (label === undefined || label === null) {\n          return;\n        }\n\n        var isLastTick = me.ticks.length === index + 1; // Since we always show the last tick,we need may need to hide the last shown one before\n\n        var shouldSkip = skipRatio > 1 && index % skipRatio > 0 || index % skipRatio === 0 && index + skipRatio >= me.ticks.length;\n\n        if (shouldSkip && !isLastTick || label === undefined || label === null) {\n          return;\n        }\n\n        var lineWidth, lineColor;\n\n        if (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {\n          // Draw the first index specially\n          lineWidth = gridLines.zeroLineWidth;\n          lineColor = gridLines.zeroLineColor;\n        } else {\n          lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);\n          lineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);\n        } // Common properties\n\n\n        var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n        var textAlign = 'middle';\n        var textBaseline = 'middle';\n\n        if (isHorizontal) {\n          if (options.position === 'bottom') {\n            // bottom\n            textBaseline = !isRotated ? 'top' : 'middle';\n            textAlign = !isRotated ? 'center' : 'right';\n            labelY = me.top + tl;\n          } else {\n            // top\n            textBaseline = !isRotated ? 'bottom' : 'middle';\n            textAlign = !isRotated ? 'center' : 'left';\n            labelY = me.bottom - tl;\n          }\n\n          var xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines\n\n          labelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n          tx1 = tx2 = x1 = x2 = xLineValue;\n          ty1 = yTickStart;\n          ty2 = yTickEnd;\n          y1 = chartArea.top;\n          y2 = chartArea.bottom;\n        } else {\n          var isLeft = options.position === 'left';\n          var tickPadding = optionTicks.padding;\n          var labelXOffset;\n\n          if (optionTicks.mirror) {\n            textAlign = isLeft ? 'left' : 'right';\n            labelXOffset = tickPadding;\n          } else {\n            textAlign = isLeft ? 'right' : 'left';\n            labelXOffset = tl + tickPadding;\n          }\n\n          labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n          var yLineValue = me.getPixelForTick(index); // xvalues for grid lines\n\n          yLineValue += helpers.aliasPixel(lineWidth);\n          labelY = me.getPixelForTick(index, gridLines.offsetGridLines);\n          tx1 = xTickStart;\n          tx2 = xTickEnd;\n          x1 = chartArea.left;\n          x2 = chartArea.right;\n          ty1 = ty2 = y1 = y2 = yLineValue;\n        }\n\n        itemsToDraw.push({\n          tx1: tx1,\n          ty1: ty1,\n          tx2: tx2,\n          ty2: ty2,\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2,\n          labelX: labelX,\n          labelY: labelY,\n          glWidth: lineWidth,\n          glColor: lineColor,\n          glBorderDash: borderDash,\n          glBorderDashOffset: borderDashOffset,\n          rotation: -1 * labelRotationRadians,\n          label: label,\n          textBaseline: textBaseline,\n          textAlign: textAlign\n        });\n      }); // Draw all of the tick labels, tick marks, and grid lines at the correct places\n\n      helpers.each(itemsToDraw, function (itemToDraw) {\n        if (gridLines.display) {\n          context.save();\n          context.lineWidth = itemToDraw.glWidth;\n          context.strokeStyle = itemToDraw.glColor;\n\n          if (context.setLineDash) {\n            context.setLineDash(itemToDraw.glBorderDash);\n            context.lineDashOffset = itemToDraw.glBorderDashOffset;\n          }\n\n          context.beginPath();\n\n          if (gridLines.drawTicks) {\n            context.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n            context.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n          }\n\n          if (gridLines.drawOnChartArea) {\n            context.moveTo(itemToDraw.x1, itemToDraw.y1);\n            context.lineTo(itemToDraw.x2, itemToDraw.y2);\n          }\n\n          context.stroke();\n          context.restore();\n        }\n\n        if (optionTicks.display) {\n          context.save();\n          context.translate(itemToDraw.labelX, itemToDraw.labelY);\n          context.rotate(itemToDraw.rotation);\n          context.font = tickFont.font;\n          context.textBaseline = itemToDraw.textBaseline;\n          context.textAlign = itemToDraw.textAlign;\n          var label = itemToDraw.label;\n\n          if (helpers.isArray(label)) {\n            for (var i = 0, y = 0; i < label.length; ++i) {\n              // We just make sure the multiline element is a string here..\n              context.fillText('' + label[i], 0, y); // apply same lineSpacing as calculated @ L#320\n\n              y += tickFont.size * 1.5;\n            }\n          } else {\n            context.fillText(label, 0, 0);\n          }\n\n          context.restore();\n        }\n      });\n\n      if (scaleLabel.display) {\n        // Draw the scale label\n        var scaleLabelX;\n        var scaleLabelY;\n        var rotation = 0;\n\n        if (isHorizontal) {\n          scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width\n\n          scaleLabelY = options.position === 'bottom' ? me.bottom - scaleLabelFont.size / 2 : me.top + scaleLabelFont.size / 2;\n        } else {\n          var isLeft = options.position === 'left';\n          scaleLabelX = isLeft ? me.left + scaleLabelFont.size / 2 : me.right - scaleLabelFont.size / 2;\n          scaleLabelY = me.top + (me.bottom - me.top) / 2;\n          rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n        }\n\n        context.save();\n        context.translate(scaleLabelX, scaleLabelY);\n        context.rotate(rotation);\n        context.textAlign = 'center';\n        context.textBaseline = 'middle';\n        context.fillStyle = scaleLabelFontColor; // render in correct colour\n\n        context.font = scaleLabelFont.font;\n        context.fillText(scaleLabel.labelString, 0, 0);\n        context.restore();\n      }\n\n      if (gridLines.drawBorder) {\n        // Draw the line at the edge of the axis\n        context.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);\n        context.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);\n        var x1 = me.left,\n            x2 = me.right,\n            y1 = me.top,\n            y2 = me.bottom;\n        var aliasPixel = helpers.aliasPixel(context.lineWidth);\n\n        if (isHorizontal) {\n          y1 = y2 = options.position === 'top' ? me.bottom : me.top;\n          y1 += aliasPixel;\n          y2 += aliasPixel;\n        } else {\n          x1 = x2 = options.position === 'left' ? me.right : me.left;\n          x1 += aliasPixel;\n          x2 += aliasPixel;\n        }\n\n        context.beginPath();\n        context.moveTo(x1, y1);\n        context.lineTo(x2, y2);\n        context.stroke();\n      }\n    }\n  });\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/core/core.scale.js"],"names":["module","exports","Chart","helpers","defaults","scale","display","position","gridLines","color","lineWidth","drawBorder","drawOnChartArea","drawTicks","tickMarkLength","zeroLineWidth","zeroLineColor","offsetGridLines","borderDash","borderDashOffset","scaleLabel","labelString","ticks","beginAtZero","minRotation","maxRotation","mirror","padding","reverse","autoSkip","autoSkipPadding","labelOffset","callback","Ticks","formatters","values","computeTextSize","context","tick","font","isArray","longestText","measureText","width","parseFontOptions","options","getValueOrDefault","globalDefaults","global","size","fontSize","defaultFontSize","style","fontStyle","defaultFontStyle","family","fontFamily","defaultFontFamily","fontString","Scale","Element","extend","getPadding","me","left","paddingLeft","top","paddingTop","right","paddingRight","bottom","paddingBottom","beforeUpdate","callCallback","update","maxWidth","maxHeight","margins","longestTextCache","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","beforeTickToLabelConversion","convertTicksToLabels","afterTickToLabelConversion","beforeCalculateTickRotation","calculateTickRotation","afterCalculateTickRotation","beforeFit","fit","afterFit","afterUpdate","minSize","isHorizontal","height","noop","tickOpts","map","userCallback","ctx","tickFont","labelRotation","originalLabelWidth","labelWidth","cosRotation","sinRotation","tickWidth","getPixelForTick","angleRadians","toRadians","Math","cos","sin","opts","scaleLabelOpts","gridLineOpts","scaleLabelFontSize","isFullWidth","largestTextWidth","tallestLabelHeightInLines","numberOfLabelLines","lineSpace","longestLabelWidth","labelHeight","min","firstTick","firstLabelWidth","lastTick","length","lastLabelWidth","handleMargins","max","fullWidth","getRightValue","rawValue","NaN","isFinite","Date","isValid","x","y","getLabelForIndex","getPixelForValue","getValueForPixel","index","includeOffset","innerWidth","pixel","finalVal","round","innerHeight","getPixelForDecimal","decimal","valueOffset","getBasePixel","getBaseValue","draw","chartArea","optionTicks","isRotated","skipRatio","useAutoskipper","maxTicks","maxTicksLimit","tickFontColor","fontColor","defaultFontColor","tl","scaleLabelFontColor","scaleLabelFont","labelRotationRadians","longestRotatedLabel","fillStyle","itemsToDraw","floor","xTickStart","xTickEnd","yTickStart","yTickEnd","each","label","undefined","isLastTick","shouldSkip","lineColor","zeroLineIndex","getValueAtIndexOrDefault","tx1","ty1","tx2","ty2","x1","y1","x2","y2","labelX","labelY","textAlign","textBaseline","xLineValue","aliasPixel","isLeft","tickPadding","labelXOffset","yLineValue","push","glWidth","glColor","glBorderDash","glBorderDashOffset","rotation","itemToDraw","save","strokeStyle","setLineDash","lineDashOffset","beginPath","moveTo","lineTo","stroke","restore","translate","rotate","i","fillText","scaleLabelX","scaleLabelY","PI"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\tChart.defaults.scale = {\n\t\tdisplay: true,\n\t\tposition: 'left',\n\n\t\t// grid line settings\n\t\tgridLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1,\n\t\t\tdrawBorder: true,\n\t\t\tdrawOnChartArea: true,\n\t\t\tdrawTicks: true,\n\t\t\ttickMarkLength: 10,\n\t\t\tzeroLineWidth: 1,\n\t\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\t\toffsetGridLines: false,\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0\n\t\t},\n\n\t\t// scale label\n\t\tscaleLabel: {\n\t\t\t// actual label\n\t\t\tlabelString: '',\n\n\t\t\t// display property\n\t\t\tdisplay: false\n\t\t},\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tbeginAtZero: false,\n\t\t\tminRotation: 0,\n\t\t\tmaxRotation: 50,\n\t\t\tmirror: false,\n\t\t\tpadding: 0,\n\t\t\treverse: false,\n\t\t\tdisplay: true,\n\t\t\tautoSkip: true,\n\t\t\tautoSkipPadding: 0,\n\t\t\tlabelOffset: 0,\n\t\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\t\tcallback: Chart.Ticks.formatters.values\n\t\t}\n\t};\n\n\tfunction computeTextSize(context, tick, font) {\n\t\treturn helpers.isArray(tick) ?\n\t\t\thelpers.longestText(context, font, tick) :\n\t\t\tcontext.measureText(tick).width;\n\t}\n\n\tfunction parseFontOptions(options) {\n\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\t\tvar globalDefaults = Chart.defaults.global;\n\t\tvar size = getValueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\t\tvar style = getValueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar family = getValueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n\n\t\treturn {\n\t\t\tsize: size,\n\t\t\tstyle: style,\n\t\t\tfamily: family,\n\t\t\tfont: helpers.fontString(size, style, family)\n\t\t};\n\t}\n\n\tChart.Scale = Chart.Element.extend({\n\t\t/**\n\t\t * Get the padding needed for the scale\n\t\t * @method getPadding\n\t\t * @private\n\t\t * @returns {Padding} the necessary padding\n\t\t */\n\t\tgetPadding: function() {\n\t\t\tvar me = this;\n\t\t\treturn {\n\t\t\t\tleft: me.paddingLeft || 0,\n\t\t\t\ttop: me.paddingTop || 0,\n\t\t\t\tright: me.paddingRight || 0,\n\t\t\t\tbottom: me.paddingBottom || 0\n\t\t\t};\n\t\t},\n\n\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t// Any function defined here is inherited by all scale types.\n\t\t// Any function can be extended by the scale type\n\n\t\tbeforeUpdate: function() {\n\t\t\thelpers.callCallback(this.options.beforeUpdate, [this]);\n\t\t},\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = helpers.extend({\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0\n\t\t\t}, margins);\n\t\t\tme.longestTextCache = me.longestTextCache || {};\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\n\t\t\t// Data min/max\n\t\t\tme.beforeDataLimits();\n\t\t\tme.determineDataLimits();\n\t\t\tme.afterDataLimits();\n\n\t\t\t// Ticks\n\t\t\tme.beforeBuildTicks();\n\t\t\tme.buildTicks();\n\t\t\tme.afterBuildTicks();\n\n\t\t\tme.beforeTickToLabelConversion();\n\t\t\tme.convertTicksToLabels();\n\t\t\tme.afterTickToLabelConversion();\n\n\t\t\t// Tick Rotation\n\t\t\tme.beforeCalculateTickRotation();\n\t\t\tme.calculateTickRotation();\n\t\t\tme.afterCalculateTickRotation();\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\n\t\t},\n\t\tafterUpdate: function() {\n\t\t\thelpers.callCallback(this.options.afterUpdate, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeSetDimensions: function() {\n\t\t\thelpers.callCallback(this.options.beforeSetDimensions, [this]);\n\t\t},\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\t\t},\n\t\tafterSetDimensions: function() {\n\t\t\thelpers.callCallback(this.options.afterSetDimensions, [this]);\n\t\t},\n\n\t\t// Data limits\n\t\tbeforeDataLimits: function() {\n\t\t\thelpers.callCallback(this.options.beforeDataLimits, [this]);\n\t\t},\n\t\tdetermineDataLimits: helpers.noop,\n\t\tafterDataLimits: function() {\n\t\t\thelpers.callCallback(this.options.afterDataLimits, [this]);\n\t\t},\n\n\t\t//\n\t\tbeforeBuildTicks: function() {\n\t\t\thelpers.callCallback(this.options.beforeBuildTicks, [this]);\n\t\t},\n\t\tbuildTicks: helpers.noop,\n\t\tafterBuildTicks: function() {\n\t\t\thelpers.callCallback(this.options.afterBuildTicks, [this]);\n\t\t},\n\n\t\tbeforeTickToLabelConversion: function() {\n\t\t\thelpers.callCallback(this.options.beforeTickToLabelConversion, [this]);\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\t// Convert ticks to strings\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);\n\t\t},\n\t\tafterTickToLabelConversion: function() {\n\t\t\thelpers.callCallback(this.options.afterTickToLabelConversion, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeCalculateTickRotation: function() {\n\t\t\thelpers.callCallback(this.options.beforeCalculateTickRotation, [this]);\n\t\t},\n\t\tcalculateTickRotation: function() {\n\t\t\tvar me = this;\n\t\t\tvar context = me.ctx;\n\t\t\tvar tickOpts = me.options.ticks;\n\n\t\t\t// Get the width of each grid by calculating the difference\n\t\t\t// between x offsets between 0 and 1.\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tcontext.font = tickFont.font;\n\n\t\t\tvar labelRotation = tickOpts.minRotation || 0;\n\n\t\t\tif (me.options.display && me.isHorizontal()) {\n\t\t\t\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, me.ticks, me.longestTextCache);\n\t\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\t\tvar cosRotation;\n\t\t\t\tvar sinRotation;\n\n\t\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\n\t\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\t\tvar angleRadians = helpers.toRadians(labelRotation);\n\t\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\t\tsinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t\t// go back one step\n\t\t\t\t\t\tlabelRotation--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelRotation++;\n\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.labelRotation = labelRotation;\n\t\t},\n\t\tafterCalculateTickRotation: function() {\n\t\t\thelpers.callCallback(this.options.afterCalculateTickRotation, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeFit: function() {\n\t\t\thelpers.callCallback(this.options.beforeFit, [this]);\n\t\t},\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\t// Reset\n\t\t\tvar minSize = me.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar display = opts.display;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tvar scaleLabelFontSize = parseFontOptions(scaleLabelOpts).size * 1.5;\n\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\n\t\t\t// Width\n\t\t\tif (isHorizontal) {\n\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t\t} else {\n\t\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t}\n\n\t\t\t// height\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t} else {\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Are we showing a title for the scale?\n\t\t\tif (scaleLabelOpts.display && display) {\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize.height += scaleLabelFontSize;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width += scaleLabelFontSize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Don't bother fitting the ticks if we are not showing them\n\t\t\tif (tickOpts.display && display) {\n\t\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, me.ticks, me.longestTextCache);\n\t\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);\n\t\t\t\tvar lineSpace = tickFont.size * 0.5;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// A horizontal axis is more constrained by the height.\n\t\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\n\t\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\t// TODO - improve this calculation\n\t\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\n\t\t\t\t\t\t+ (tickFont.size * tallestLabelHeightInLines)\n\t\t\t\t\t\t+ (lineSpace * tallestLabelHeightInLines);\n\n\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);\n\t\t\t\t\tme.ctx.font = tickFont.font;\n\n\t\t\t\t\tvar firstTick = me.ticks[0];\n\t\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, firstTick, tickFont.font);\n\n\t\t\t\t\tvar lastTick = me.ticks[me.ticks.length - 1];\n\t\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, lastTick, tickFont.font);\n\n\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated\n\t\t\t\t\t// by the font height\n\t\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\t\tme.paddingLeft = opts.position === 'bottom'? (cosRotation * firstLabelWidth) + 3: (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = opts.position === 'bottom'? (cosRotation * lineSpace) + 3: (cosRotation * lastLabelWidth) + 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = lastLabelWidth / 2 + 3;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first\n\t\t\t\t\t// Account for padding\n\n\t\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlargestTextWidth += me.options.ticks.padding;\n\t\t\t\t\t}\n\t\t\t\t\tminSize.width += largestTextWidth;\n\t\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.handleMargins();\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\n\t\t/**\n\t\t * Handle margins and padding interactions\n\t\t * @private\n\t\t */\n\t\thandleMargins: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.margins) {\n\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t\t}\n\t\t},\n\n\t\tafterFit: function() {\n\t\t\thelpers.callCallback(this.options.afterFit, [this]);\n\t\t},\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\t\tisFullWidth: function() {\n\t\t\treturn (this.options.fullWidth);\n\t\t},\n\n\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\t\tgetRightValue: function(rawValue) {\n\t\t\t// Null and undefined values first\n\t\t\tif (rawValue === null || typeof(rawValue) === 'undefined') {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\t\tif (typeof(rawValue) === 'number' && !isFinite(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// If it is in fact an object, dive in one more level\n\t\t\tif (typeof(rawValue) === 'object') {\n\t\t\t\tif ((rawValue instanceof Date) || (rawValue.isValid)) {\n\t\t\t\t\treturn rawValue;\n\t\t\t\t}\n\t\t\t\treturn this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);\n\t\t\t}\n\n\t\t\t// Value is good, return it\n\t\t\treturn rawValue;\n\t\t},\n\n\t\t// Used to get the value to display in the tooltip for the data at the given index\n\t\t// function getLabelForIndex(index, datasetIndex)\n\t\tgetLabelForIndex: helpers.noop,\n\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: helpers.noop,\n\n\t\t// Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t\tgetValueForPixel: helpers.noop,\n\n\t\t// Used for tick location, should\n\t\tgetPixelForTick: function(index, includeOffset) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n\t\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\n\t\t\t\tif (includeOffset) {\n\t\t\t\t\tpixel += tickWidth / 2;\n\t\t\t\t}\n\n\t\t\t\tvar finalVal = me.left + Math.round(pixel);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\treturn me.top + (index * (innerHeight / (me.ticks.length - 1)));\n\t\t},\n\n\t\t// Utility for getting the pixel location of a percentage of scale\n\t\tgetPixelForDecimal: function(decimal /* , includeOffset*/) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\n\t\t\t\tvar finalVal = me.left + Math.round(valueOffset);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\treturn me.top + (decimal * me.height);\n\t\t},\n\n\t\tgetBasePixel: function() {\n\t\t\treturn this.getPixelForValue(this.getBaseValue());\n\t\t},\n\n\t\tgetBaseValue: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.beginAtZero ? 0:\n\t\t\t\tmin < 0 && max < 0? max :\n\t\t\t\tmin > 0 && max > 0? min :\n\t\t\t\t0;\n\t\t},\n\n\t\t// Actually draw the scale on the canvas\n\t\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n\t\tdraw: function(chartArea) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tif (!options.display) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar context = me.ctx;\n\t\t\tvar globalDefaults = Chart.defaults.global;\n\t\t\tvar optionTicks = options.ticks;\n\t\t\tvar gridLines = options.gridLines;\n\t\t\tvar scaleLabel = options.scaleLabel;\n\n\t\t\tvar isRotated = me.labelRotation !== 0;\n\t\t\tvar skipRatio;\n\t\t\tvar useAutoskipper = optionTicks.autoSkip;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\t// figure out the maximum number of gridlines to show\n\t\t\tvar maxTicks;\n\t\t\tif (optionTicks.maxTicksLimit) {\n\t\t\t\tmaxTicks = optionTicks.maxTicksLimit;\n\t\t\t}\n\n\t\t\tvar tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar tickFont = parseFontOptions(optionTicks);\n\n\t\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\t\t\tvar borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n\t\t\tvar borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n\n\t\t\tvar scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar scaleLabelFont = parseFontOptions(scaleLabel);\n\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\t\t\tvar cosRotation = Math.cos(labelRotationRadians);\n\t\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\n\n\t\t\t// Make sure we draw text in the correct color and font\n\t\t\tcontext.fillStyle = tickFontColor;\n\n\t\t\tvar itemsToDraw = [];\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tskipRatio = false;\n\n\t\t\t\t// Only calculate the skip ratio with the half width of longestRotateLabel if we got an actual rotation\n\t\t\t\t// See #2584\n\t\t\t\tif (isRotated) {\n\t\t\t\t\tlongestRotatedLabel /= 2;\n\t\t\t\t}\n\n\t\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > (me.width - (me.paddingLeft + me.paddingRight))) {\n\t\t\t\t\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));\n\t\t\t\t}\n\n\t\t\t\t// if they defined a max number of optionTicks,\n\t\t\t\t// increase skipRatio until that number is met\n\t\t\t\tif (maxTicks && me.ticks.length > maxTicks) {\n\t\t\t\t\twhile (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {\n\t\t\t\t\t\tif (!skipRatio) {\n\t\t\t\t\t\t\tskipRatio = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tskipRatio += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!useAutoskipper) {\n\t\t\t\t\tskipRatio = false;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tvar xTickStart = options.position === 'right' ? me.left : me.right - tl;\n\t\t\tvar xTickEnd = options.position === 'right' ? me.left + tl : me.right;\n\t\t\tvar yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;\n\t\t\tvar yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;\n\n\t\t\thelpers.each(me.ticks, function(label, index) {\n\t\t\t\t// If the callback returned a null or undefined value, do not draw this line\n\t\t\t\tif (label === undefined || label === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar isLastTick = me.ticks.length === index + 1;\n\n\t\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before\n\t\t\t\tvar shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio >= me.ticks.length);\n\t\t\t\tif (shouldSkip && !isLastTick || (label === undefined || label === null)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar lineWidth, lineColor;\n\t\t\t\tif (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {\n\t\t\t\t\t// Draw the first index specially\n\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\t} else {\n\t\t\t\t\tlineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\t\tlineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\t}\n\n\t\t\t\t// Common properties\n\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n\t\t\t\tvar textAlign = 'middle';\n\t\t\t\tvar textBaseline = 'middle';\n\n\t\t\t\tif (isHorizontal) {\n\n\t\t\t\t\tif (options.position === 'bottom') {\n\t\t\t\t\t\t// bottom\n\t\t\t\t\t\ttextBaseline = !isRotated? 'top':'middle';\n\t\t\t\t\t\ttextAlign = !isRotated? 'center': 'right';\n\t\t\t\t\t\tlabelY = me.top + tl;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// top\n\t\t\t\t\t\ttextBaseline = !isRotated? 'bottom':'middle';\n\t\t\t\t\t\ttextAlign = !isRotated? 'center': 'left';\n\t\t\t\t\t\tlabelY = me.bottom - tl;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines\n\t\t\t\t\tlabelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n\t\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;\n\t\t\t\t\tty1 = yTickStart;\n\t\t\t\t\tty2 = yTickEnd;\n\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\ty2 = chartArea.bottom;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tvar tickPadding = optionTicks.padding;\n\t\t\t\t\tvar labelXOffset;\n\n\t\t\t\t\tif (optionTicks.mirror) {\n\t\t\t\t\t\ttextAlign = isLeft ? 'left' : 'right';\n\t\t\t\t\t\tlabelXOffset = tickPadding;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttextAlign = isLeft ? 'right' : 'left';\n\t\t\t\t\t\tlabelXOffset = tl + tickPadding;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n\n\t\t\t\t\tvar yLineValue = me.getPixelForTick(index); // xvalues for grid lines\n\t\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);\n\t\t\t\t\tlabelY = me.getPixelForTick(index, gridLines.offsetGridLines);\n\n\t\t\t\t\ttx1 = xTickStart;\n\t\t\t\t\ttx2 = xTickEnd;\n\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\tx2 = chartArea.right;\n\t\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;\n\t\t\t\t}\n\n\t\t\t\titemsToDraw.push({\n\t\t\t\t\ttx1: tx1,\n\t\t\t\t\tty1: ty1,\n\t\t\t\t\ttx2: tx2,\n\t\t\t\t\tty2: ty2,\n\t\t\t\t\tx1: x1,\n\t\t\t\t\ty1: y1,\n\t\t\t\t\tx2: x2,\n\t\t\t\t\ty2: y2,\n\t\t\t\t\tlabelX: labelX,\n\t\t\t\t\tlabelY: labelY,\n\t\t\t\t\tglWidth: lineWidth,\n\t\t\t\t\tglColor: lineColor,\n\t\t\t\t\tglBorderDash: borderDash,\n\t\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\t\tlabel: label,\n\t\t\t\t\ttextBaseline: textBaseline,\n\t\t\t\t\ttextAlign: textAlign\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\t\thelpers.each(itemsToDraw, function(itemToDraw) {\n\t\t\t\tif (gridLines.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;\n\t\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;\n\t\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.beginPath();\n\n\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\n\t\t\t\tif (optionTicks.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\t\tcontext.font = tickFont.font;\n\t\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;\n\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\n\t\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\t\tfor (var i = 0, y = 0; i < label.length; ++i) {\n\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320\n\t\t\t\t\t\t\ty += (tickFont.size * 1.5);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.fillText(label, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (scaleLabel.display) {\n\t\t\t\t// Draw the scale label\n\t\t\t\tvar scaleLabelX;\n\t\t\t\tvar scaleLabelY;\n\t\t\t\tvar rotation = 0;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\t\tscaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFont.size / 2) : me.top + (scaleLabelFont.size / 2);\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tscaleLabelX = isLeft ? me.left + (scaleLabelFont.size / 2) : me.right - (scaleLabelFont.size / 2);\n\t\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t\t}\n\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\t\tcontext.rotate(rotation);\n\t\t\t\tcontext.textAlign = 'center';\n\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\t\tcontext.font = scaleLabelFont.font;\n\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\t\tcontext.restore();\n\t\t\t}\n\n\t\t\tif (gridLines.drawBorder) {\n\t\t\t\t// Draw the line at the edge of the axis\n\t\t\t\tcontext.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);\n\t\t\t\tcontext.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);\n\t\t\t\tvar x1 = me.left,\n\t\t\t\t\tx2 = me.right,\n\t\t\t\t\ty1 = me.top,\n\t\t\t\t\ty2 = me.bottom;\n\n\t\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\n\t\t\t\t\ty1 += aliasPixel;\n\t\t\t\t\ty2 += aliasPixel;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;\n\t\t\t\t\tx1 += aliasPixel;\n\t\t\t\t\tx2 += aliasPixel;\n\t\t\t\t}\n\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(x1, y1);\n\t\t\t\tcontext.lineTo(x2, y2);\n\t\t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}