{"ast":null,"code":"'use strict';\n\nmodule.exports = function (Chart) {\n  var helpers = Chart.helpers;\n  /**\n   * Namespace to hold static tick generation functions\n   * @namespace Chart.Ticks\n   */\n\n  Chart.Ticks = {\n    /**\n     * Namespace to hold generators for different types of ticks\n     * @namespace Chart.Ticks.generators\n     */\n    generators: {\n      /**\n       * Interface for the options provided to the numeric tick generator\n       * @interface INumericTickGenerationOptions\n       */\n\n      /**\n       * The maximum number of ticks to display\n       * @name INumericTickGenerationOptions#maxTicks\n       * @type Number\n       */\n\n      /**\n       * The distance between each tick.\n       * @name INumericTickGenerationOptions#stepSize\n       * @type Number\n       * @optional\n       */\n\n      /**\n       * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\n       * @name INumericTickGenerationOptions#min\n       * @type Number\n       * @optional\n       */\n\n      /**\n       * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\n       * @name INumericTickGenerationOptions#max\n       * @type Number\n       * @optional\n       */\n\n      /**\n       * Generate a set of linear ticks\n       * @method Chart.Ticks.generators.linear\n       * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n       * @param dataRange {IRange} the range of the data\n       * @returns {Array<Number>} array of tick values\n       */\n      linear: function (generationOptions, dataRange) {\n        var ticks = []; // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n        // \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n        // for details.\n\n        var spacing;\n\n        if (generationOptions.stepSize && generationOptions.stepSize > 0) {\n          spacing = generationOptions.stepSize;\n        } else {\n          var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n          spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n        }\n\n        var niceMin = Math.floor(dataRange.min / spacing) * spacing;\n        var niceMax = Math.ceil(dataRange.max / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.\n\n        if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n          // If very close to our whole number, use it.\n          if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n            niceMin = generationOptions.min;\n            niceMax = generationOptions.max;\n          }\n        }\n\n        var numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.\n\n        if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n          numSpaces = Math.round(numSpaces);\n        } else {\n          numSpaces = Math.ceil(numSpaces);\n        } // Put the values into the ticks array\n\n\n        ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\n        for (var j = 1; j < numSpaces; ++j) {\n          ticks.push(niceMin + j * spacing);\n        }\n\n        ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n        return ticks;\n      },\n\n      /**\n       * Generate a set of logarithmic ticks\n       * @method Chart.Ticks.generators.logarithmic\n       * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n       * @param dataRange {IRange} the range of the data\n       * @returns {Array<Number>} array of tick values\n       */\n      logarithmic: function (generationOptions, dataRange) {\n        var ticks = [];\n        var getValueOrDefault = helpers.getValueOrDefault; // Figure out what the max number of ticks we can support it is based on the size of\n        // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n        // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n        // the graph\n\n        var tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n        var endExp = Math.floor(helpers.log10(dataRange.max));\n        var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n        var exp;\n        var significand;\n\n        if (tickVal === 0) {\n          exp = Math.floor(helpers.log10(dataRange.minNotZero));\n          significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n          ticks.push(tickVal);\n          tickVal = significand * Math.pow(10, exp);\n        } else {\n          exp = Math.floor(helpers.log10(tickVal));\n          significand = Math.floor(tickVal / Math.pow(10, exp));\n        }\n\n        do {\n          ticks.push(tickVal);\n          ++significand;\n\n          if (significand === 10) {\n            significand = 1;\n            ++exp;\n          }\n\n          tickVal = significand * Math.pow(10, exp);\n        } while (exp < endExp || exp === endExp && significand < endSignificand);\n\n        var lastTick = getValueOrDefault(generationOptions.max, tickVal);\n        ticks.push(lastTick);\n        return ticks;\n      }\n    },\n\n    /**\n     * Namespace to hold formatters for different types of ticks\n     * @namespace Chart.Ticks.formatters\n     */\n    formatters: {\n      /**\n       * Formatter for value labels\n       * @method Chart.Ticks.formatters.values\n       * @param value the value to display\n       * @return {String|Array} the label to display\n       */\n      values: function (value) {\n        return helpers.isArray(value) ? value : '' + value;\n      },\n\n      /**\n       * Formatter for linear numeric ticks\n       * @method Chart.Ticks.formatters.linear\n       * @param tickValue {Number} the value to be formatted\n       * @param index {Number} the position of the tickValue parameter in the ticks array\n       * @param ticks {Array<Number>} the list of ticks being converted\n       * @return {String} string representation of the tickValue parameter\n       */\n      linear: function (tickValue, index, ticks) {\n        // If we have lots of ticks, don't use the ones\n        var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\n        if (Math.abs(delta) > 1) {\n          if (tickValue !== Math.floor(tickValue)) {\n            // not an integer\n            delta = tickValue - Math.floor(tickValue);\n          }\n        }\n\n        var logDelta = helpers.log10(Math.abs(delta));\n        var tickString = '';\n\n        if (tickValue !== 0) {\n          var numDecimal = -1 * Math.floor(logDelta);\n          numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\n          tickString = tickValue.toFixed(numDecimal);\n        } else {\n          tickString = '0'; // never show decimal places for 0\n        }\n\n        return tickString;\n      },\n      logarithmic: function (tickValue, index, ticks) {\n        var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));\n\n        if (tickValue === 0) {\n          return '0';\n        } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n          return tickValue.toExponential();\n        }\n\n        return '';\n      }\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/Kronos/Documents/Programming/Web/React/CS-3750-Project/ClientApp/node_modules/chart.js/src/core/core.ticks.js"],"names":["module","exports","Chart","helpers","Ticks","generators","linear","generationOptions","dataRange","ticks","spacing","stepSize","niceRange","niceNum","max","min","maxTicks","niceMin","Math","floor","niceMax","ceil","almostWhole","numSpaces","almostEquals","round","push","undefined","j","logarithmic","getValueOrDefault","tickVal","pow","log10","endExp","endSignificand","exp","significand","minNotZero","lastTick","formatters","values","value","isArray","tickValue","index","delta","length","abs","logDelta","tickString","numDecimal","toFixed","remain","toExponential"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(Chart) {\n\n\tvar helpers = Chart.helpers;\n\n\t/**\n\t * Namespace to hold static tick generation functions\n\t * @namespace Chart.Ticks\n\t */\n\tChart.Ticks = {\n\t\t/**\n\t\t * Namespace to hold generators for different types of ticks\n\t\t * @namespace Chart.Ticks.generators\n\t\t */\n\t\tgenerators: {\n\t\t\t/**\n\t\t\t * Interface for the options provided to the numeric tick generator\n\t\t\t * @interface INumericTickGenerationOptions\n\t\t\t */\n\t\t\t/**\n\t\t\t * The maximum number of ticks to display\n\t\t\t * @name INumericTickGenerationOptions#maxTicks\n\t\t\t * @type Number\n\t\t\t */\n\t\t\t/**\n\t\t\t * The distance between each tick.\n\t\t\t * @name INumericTickGenerationOptions#stepSize\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\t\t\t/**\n\t\t\t * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\n\t\t\t * @name INumericTickGenerationOptions#min\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\t\t\t/**\n\t\t\t * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\n\t\t\t * @name INumericTickGenerationOptions#max\n\t\t\t * @type Number\n\t\t\t * @optional\n\t\t\t */\n\n\t\t\t/**\n\t\t\t * Generate a set of linear ticks\n\t\t\t * @method Chart.Ticks.generators.linear\n\t\t\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n\t\t\t * @param dataRange {IRange} the range of the data\n\t\t\t * @returns {Array<Number>} array of tick values\n\t\t\t */\n\t\t\tlinear: function(generationOptions, dataRange) {\n\t\t\t\tvar ticks = [];\n\t\t\t\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t\t\t\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t\t\t\t// for details.\n\n\t\t\t\tvar spacing;\n\t\t\t\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\t\t\t\tspacing = generationOptions.stepSize;\n\t\t\t\t} else {\n\t\t\t\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\t\t\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\t\t\t\t}\n\t\t\t\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\t\t\t\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\n\t\t\t\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\t\t\t\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n\t\t\t\t\t// If very close to our whole number, use it.\n\t\t\t\t\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n\t\t\t\t\t\tniceMin = generationOptions.min;\n\t\t\t\t\t\tniceMax = generationOptions.max;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t\t\t\t// If very close to our rounded value, use it.\n\t\t\t\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\t\t\t\tnumSpaces = Math.round(numSpaces);\n\t\t\t\t} else {\n\t\t\t\t\tnumSpaces = Math.ceil(numSpaces);\n\t\t\t\t}\n\n\t\t\t\t// Put the values into the ticks array\n\t\t\t\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\t\t\t\tfor (var j = 1; j < numSpaces; ++j) {\n\t\t\t\t\tticks.push(niceMin + (j * spacing));\n\t\t\t\t}\n\t\t\t\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\n\t\t\t\treturn ticks;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Generate a set of logarithmic ticks\n\t\t\t * @method Chart.Ticks.generators.logarithmic\n\t\t\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n\t\t\t * @param dataRange {IRange} the range of the data\n\t\t\t * @returns {Array<Number>} array of tick values\n\t\t\t */\n\t\t\tlogarithmic: function(generationOptions, dataRange) {\n\t\t\t\tvar ticks = [];\n\t\t\t\tvar getValueOrDefault = helpers.getValueOrDefault;\n\n\t\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t\t// the graph\n\t\t\t\tvar tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\n\t\t\t\tvar endExp = Math.floor(helpers.log10(dataRange.max));\n\t\t\t\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\t\t\t\tvar exp;\n\t\t\t\tvar significand;\n\n\t\t\t\tif (tickVal === 0) {\n\t\t\t\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\t\t\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\t\t\t\tticks.push(tickVal);\n\t\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t\t} else {\n\t\t\t\t\texp = Math.floor(helpers.log10(tickVal));\n\t\t\t\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t\t\t\t}\n\n\t\t\t\tdo {\n\t\t\t\t\tticks.push(tickVal);\n\n\t\t\t\t\t++significand;\n\t\t\t\t\tif (significand === 10) {\n\t\t\t\t\t\tsignificand = 1;\n\t\t\t\t\t\t++exp;\n\t\t\t\t\t}\n\n\t\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\n\t\t\t\tvar lastTick = getValueOrDefault(generationOptions.max, tickVal);\n\t\t\t\tticks.push(lastTick);\n\n\t\t\t\treturn ticks;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Namespace to hold formatters for different types of ticks\n\t\t * @namespace Chart.Ticks.formatters\n\t\t */\n\t\tformatters: {\n\t\t\t/**\n\t\t\t * Formatter for value labels\n\t\t\t * @method Chart.Ticks.formatters.values\n\t\t\t * @param value the value to display\n\t\t\t * @return {String|Array} the label to display\n\t\t\t */\n\t\t\tvalues: function(value) {\n\t\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Formatter for linear numeric ticks\n\t\t\t * @method Chart.Ticks.formatters.linear\n\t\t\t * @param tickValue {Number} the value to be formatted\n\t\t\t * @param index {Number} the position of the tickValue parameter in the ticks array\n\t\t\t * @param ticks {Array<Number>} the list of ticks being converted\n\t\t\t * @return {String} string representation of the tickValue parameter\n\t\t\t */\n\t\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\n\t\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t\t// not an integer\n\t\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\t\tvar tickString = '';\n\n\t\t\t\tif (tickValue !== 0) {\n\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t\t} else {\n\t\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t\t}\n\n\t\t\t\treturn tickString;\n\t\t\t},\n\n\t\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\n\n\t\t\t\tif (tickValue === 0) {\n\t\t\t\t\treturn '0';\n\t\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\t\treturn tickValue.toExponential();\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t};\n};\n"]},"metadata":{},"sourceType":"script"}